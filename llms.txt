Project Structure:
📁 vexy-glob
├── 📁 .github
│   ├── 📁 workflows
│   │   ├── 📄 ci.yml
│   │   ├── 📄 coverage.yml
│   │   ├── 📄 dependencies.yml
│   │   └── 📄 release.yml
│   └── 📄 dependabot.yml
├── 📁 examples
│   ├── 📄 compare_stdlib.py
│   ├── 📄 demo.py
│   └── 📄 pafrbench.py
├── 📁 issues
├── 📁 ref
├── 📁 src
│   └── 📄 lib.rs
├── 📁 target
│   ├── 📁 debug
│   │   ├── 📁 deps
│   │   ├── 📁 examples
│   │   └── 📁 incremental
│   │       ├── 📁 
│   │       │   pafr-2qy9vx5prgo3z
│   │       │   └── 📁 
│   │       │       s-h9stjuu82p-0wy
│   │       │       1o7w-6ijd8nvk3sp
│   │       │       h9ai7vwo87nzf6
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   pafr-3k3ufq6npu65c
│   │       │   └── 📁 
│   │       │       s-h9stjuu8dr-0wp
│   │       │       vucw-b6m44sjb4uo
│   │       │       pzavvg500bh1d3
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   pafr-3vcerdictosdl
│   │       │   └── 📁 
│   │       │       s-h9sygw5sed-0j2
│   │       │       7mtq-cl9j1pe6i51
│   │       │       6756ts3550wrdg
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   vexy_glob-0214p87xb2
│   │       │   a1g
│   │       │   └── 📁 
│   │       │       s-h9t098e2d4-1do
│   │       │       12nc-9vx2udpm8k8
│   │       │       3erlvfr0w5zspn
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   vexy_glob-0dko6auggy
│   │       │   fat
│   │       │   ├── 📁 
│   │       │   │   s-h9sz18qkca-05q
│   │       │   │   smuc-working
│   │       │   │   └── ... (depth 
│   │       │   │       limit 
│   │       │   │       reached)
│   │       │   └── 📁 
│   │       │       s-h9sz19pa87-13i
│   │       │       nbo1-8kmg2pfathp
│   │       │       ezlpa0gn5t8ukd
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   vexy_glob-0o0uuwmbfk
│   │       │   i5z
│   │       │   └── 📁 
│   │       │       s-h9t098e2dd-0xi
│   │       │       4928-c4pk1st2nb0
│   │       │       tgj2nuhcp109mq
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   vexy_glob-173gufp31m
│   │       │   ci0
│   │       │   └── 📁 
│   │       │       s-h9t0p0yleo-0sq
│   │       │       12de-4z1cvvatooo
│   │       │       rg6qwg9oe91tx4
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   vexy_glob-1lw82dsdfc
│   │       │   39b
│   │       │   ├── 📁 
│   │       │   │   s-h9sz18qj2k-026
│   │       │   │   m52i-working
│   │       │   │   └── ... (depth 
│   │       │   │       limit 
│   │       │   │       reached)
│   │       │   └── 📁 
│   │       │       s-h9sz19p74t-1td
│   │       │       0d1a-dfmc8tluie8
│   │       │       hdh1b468t9irkz
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   vexy_glob-1xffhew2ot
│   │       │   q30
│   │       │   └── 📁 
│   │       │       s-h9t05ab46q-02r
│   │       │       swlq-1xx6sifycg0
│   │       │       wcmewh2c946qm9
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       ├── 📁 
│   │       │   vexy_glob-2dx3kma3n1
│   │       │   6so
│   │       │   └── 📁 
│   │       │       s-h9t05ab42z-1ko
│   │       │       1dkt-awuy4juducp
│   │       │       5flkxa6as3c4st
│   │       │       └── ... (depth 
│   │       │           limit 
│   │       │           reached)
│   │       └── 📁 
│   │           vexy_glob-2iibnjz9ek
│   │           8q6
│   │           └── 📁 
│   │               s-h9t0p0ylbm-0di
│   │               hf1p-bf8prejuohl
│   │               aszabpf65pg9vb
│   │               └── ... (depth 
│   │                   limit 
│   │                   reached)
│   ├── 📁 doc
│   │   ├── 📁 pafr
│   │   ├── 📁 search.desc
│   │   │   └── 📁 pafr
│   │   ├── 📁 src
│   │   │   └── 📁 pafr
│   │   ├── 📁 static.files
│   │   └── 📁 trait.impl
│   │       └── 📁 core
│   │           ├── 📁 clone
│   │           │   └── ... (depth 
│   │           │       limit 
│   │           │       reached)
│   │           ├── 📁 fmt
│   │           │   └── ... (depth 
│   │           │       limit 
│   │           │       reached)
│   │           ├── 📁 marker
│   │           │   └── ... (depth 
│   │           │       limit 
│   │           │       reached)
│   │           └── 📁 panic
│   │               └── ... (depth 
│   │                   limit 
│   │                   reached)
│   ├── 📁 maturin
│   ├── 📁 release
│   │   ├── 📁 deps
│   │   ├── 📁 examples
│   │   └── 📁 incremental
│   └── 📁 wheels
├── 📁 test_gitignore
│   ├── 📁 test_gitignore
│   └── 📄 .gitignore
├── 📁 tests
│   ├── 📄 test_atime_filtering.py
│   ├── 📄 test_basic.py
│   ├── 📄 test_cli.py
│   ├── 📄 test_ctime_filtering.py
│   ├── 📄 test_custom_ignore.py
│   ├── 📄 test_exclude_patterns.py
│   ├── 📄 test_size_filtering.py
│   ├── 📄 test_symlinks.py
│   ├── 📄 test_time_filtering.py
│   └── 📄 test_time_formats.py
├── 📁 vexy_glob
│   ├── 📄 __init__.py
│   └── 📄 __main__.py
├── 📄 .gitignore
├── 📄 AGENTS.md
├── 📄 build.sh
├── 📄 Cargo.toml
├── 📄 CHANGELOG.md
├── 📄 CLAUDE.md
├── 📄 CONTRIBUTING.md
├── 📄 GEMINI.md
├── 📄 LICENSE
├── 📄 PLAN.md
├── 📄 publish.sh
├── 📄 pyproject.toml
├── 📄 README.md
├── 📄 sync_version.py
├── 📄 TODO.md
└── 📄 WORK.md


<documents>
<document index="1">
<source>.cursorrules</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

`vexy_glob` (Path Accelerated Finding in Rust) is a high-performance Python-Rust extension that provides dramatically faster file system traversal and content searching compared to Python's built-in `glob` and `pathlib` modules. It wraps the Rust crates `fd` (ignore) and `ripgrep` (grep-searcher) functionality with a Pythonic API.

Key performance goals:
- 10-100x faster than Python stdlib for file finding
- Stream first results in <5ms (vs 500ms+ for stdlib)
- Constant memory usage regardless of result count
- Full CPU parallelization

## 2. Development Commands

### 2.1. Setting Up the Project
```bash
# Initial setup for Python-Rust extension
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add maturin pyo3 pytest fire rich loguru
uv sync

# Install Rust toolchain if not present
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### 2.2. Building the Extension
```bash
# Development build
maturin develop

# Release build with optimizations
maturin develop --release

# Build wheel for distribution
maturin build --release
```

### 2.3. Running Tests
```bash
# Run Python tests
python -m pytest tests/ -v

# Run Rust tests
cargo test

# Run benchmarks against stdlib
python -m pytest tests/benchmarks/ -v --benchmark-only
```

### 2.4. Code Quality
```bash
# Python linting and formatting
fd -e py -x uvx autoflake -i {}
fd -e py -x uvx pyupgrade --py312-plus {}
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}

# Rust linting and formatting
cargo fmt
cargo clippy -- -D warnings
```

## 3. Architecture Overview

### 3.1. Core Components

1. **Rust Extension Module** (`src/lib.rs`)
   - PyO3 bindings exposing `find()` function to Python
   - Producer-consumer architecture using crossbeam-channel
   - Wrapper around `ignore` crate for traversal and `grep-searcher` for content search

2. **Python API** (`vexy_glob/__init__.py`)
   - Main entry point: `vexy_glob.find(pattern, content=None, root=".", **options)`
   - Iterator-based streaming API with optional list materialization
   - Exception hierarchy: `VexyGlobError`, `PatternError`, `SearchError`, `TraversalNotSupportedError`

3. **Key Design Decisions**
   - **Depth-first traversal only** - Breadth-first causes memory explosion with gitignore files
   - **GIL release during Rust operations** - Enables true parallelism
   - **Streaming by default** - Results yielded as discovered via crossbeam channels
   - **Smart defaults** - Respects .gitignore, skips hidden files unless specified

### 3.2. Critical Implementation Details

1. **Pattern Matching**
   - Uses `globset` crate for efficient glob patterns
   - Case-insensitive by default unless pattern contains uppercase
   - Supports advanced patterns: `**/*.py`, `{src,tests}/**/*.rs`

2. **Content Search**
   - Optional regex search within files using `grep-regex`
   - Binary file detection using NUL byte heuristic
   - SIMD optimizations via Teddy algorithm for multi-pattern matching

3. **Performance Optimizations**
   - Zero-copy operations using Rust `Path`/`PathBuf`
   - Thread pool tuning based on I/O vs CPU workload
   - Buffer sizes: 8KB for traversal, 64KB-256KB for content search

## 4. Development Workflow

1. **File Path Tracking**: All source files must include `# this_file: path/to/file` comment
2. **Documentation**: Maintain WORK.md, PLAN.md, TODO.md, and CHANGELOG.md
3. **Incremental Development**: Focus on minimal viable increments
4. **Testing**: Write tests for all new functionality, especially performance benchmarks

## 5. Common Tasks

### 5.1. Adding a New Option
1. Add parameter to Rust `FindOptions` struct
2. Update PyO3 binding in `find()` function signature
3. Add Python API parameter with appropriate default
4. Update tests and documentation

### 5.2. Debugging Performance
1. Use `cargo flamegraph` for Rust profiling
2. Python `cProfile` for API overhead analysis
3. Compare against baseline benchmarks in `tests/benchmarks/`

### 5.3. Releasing
1. Update version in `Cargo.toml` and `pyproject.toml`
2. Run full test suite including benchmarks
3. Build wheels: `maturin build --release --strip`
4. Upload to PyPI: `maturin publish`

## 6. Important Constraints

- Must maintain Python 3.8+ compatibility
- No external runtime dependencies (all Rust compiled into extension)
- Cross-platform support required (Linux, macOS, Windows)
- API must remain drop-in compatible with `glob.glob()` basic usage


--- 

# Software Development Rules

## 7. Pre-Work Preparation

### 7.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 7.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 8. General Coding Principles

### 8.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 8.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 9. Tool Usage (When Available)

### 9.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 10. File Management

### 10.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 11. Python-Specific Guidelines

### 11.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 11.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 11.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 11.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 12. Post-Work Activities

### 12.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 12.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 13. Work Methodology

### 13.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 13.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 14. Special Commands

### 14.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 14.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 14.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 15. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 16. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate



</document_content>
</document>

<document index="2">
<source>.github/dependabot.yml</source>
<document_content>
# this_file: .github/dependabot.yml
version: 2
updates:
  # GitHub Actions
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
    commit-message:
      prefix: "ci"
    
  # Rust dependencies
  - package-ecosystem: "cargo"
    directory: "/"
    schedule:
      interval: "weekly"
    commit-message:
      prefix: "chore"
    open-pull-requests-limit: 5
</document_content>
</document>

<document index="3">
<source>.github/workflows/ci.yml</source>
<document_content>
# this_file: .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Run tests on multiple platforms
  test:
    name: Test - ${{ matrix.os }} - Python ${{ matrix.python-version }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.8', '3.9', '3.10', '3.11', '3.12']
        exclude:
          # macOS runners are expensive, only test latest Python
          - os: macos-latest
            python-version: '3.8'
          - os: macos-latest
            python-version: '3.9'
          - os: macos-latest
            python-version: '3.10'
          - os: macos-latest
            python-version: '3.11'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Set up Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    
    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install maturin pytest pytest-benchmark setuptools-scm
    
    - name: Build extension in development mode
      run: |
        python sync_version.py
        maturin develop
    
    - name: Run Rust tests
      run: cargo test --verbose
    
    - name: Run Rust clippy
      run: cargo clippy -- -D warnings
    
    - name: Check Rust formatting
      run: cargo fmt -- --check
    
    - name: Run Python tests
      run: pytest tests/ -v
    
    - name: Run benchmarks (without comparison)
      run: pytest tests/test_benchmarks.py -v --benchmark-only --benchmark-disable-gc

  # Build wheels for distribution
  build-wheels:
    name: Build wheels - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
    
    - name: Set up Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Install cibuildwheel
      run: python -m pip install cibuildwheel
    
    - name: Build wheels
      run: python -m cibuildwheel --output-dir wheelhouse
      env:
        CIBW_BUILD: cp38-* cp39-* cp310-* cp311-* cp312-*
        CIBW_SKIP: "*-musllinux_i686 *-win32 pp*"
        CIBW_MANYLINUX_X86_64_IMAGE: manylinux2014
        CIBW_MANYLINUX_I686_IMAGE: manylinux2014
        CIBW_BEFORE_BUILD: pip install maturin setuptools-scm && python sync_version.py
        CIBW_BUILD_FRONTEND: "pip"
        CIBW_ENVIRONMENT: 'PATH="$HOME/.cargo/bin:$PATH"'
        CIBW_ENVIRONMENT_WINDOWS: 'PATH="$UserProfile\.cargo\bin;$PATH"'
    
    - name: Upload wheels
      uses: actions/upload-artifact@v4
      with:
        name: wheels-${{ matrix.os }}
        path: ./wheelhouse/*.whl

  # Build source distribution
  build-sdist:
    name: Build source distribution
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
    
    - name: Set up Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Install build tools
      run: pip install maturin setuptools-scm
    
    - name: Build sdist
      run: |
        python sync_version.py
        maturin sdist -o dist/
    
    - name: Upload sdist
      uses: actions/upload-artifact@v4
      with:
        name: sdist
        path: ./dist/*.tar.gz

  # Publish to PyPI
  publish:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [test, build-wheels, build-sdist]
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Download wheels
      uses: actions/download-artifact@v4
      with:
        pattern: wheels-*
        merge-multiple: true
        path: dist
    
    - name: Download sdist
      uses: actions/download-artifact@v4
      with:
        name: sdist
        path: dist
    
    - name: List distribution files
      run: ls -la dist/
    
    - name: Publish to Test PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/
        skip-existing: true
        verbose: true
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}
    
    # Only publish to real PyPI for non-pre-release tags
    - name: Publish to PyPI
      if: "!contains(github.ref, 'rc') && !contains(github.ref, 'beta') && !contains(github.ref, 'alpha')"
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        skip-existing: true
        verbose: true
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
</document_content>
</document>

<document index="4">
<source>.github/workflows/coverage.yml</source>
<document_content>
# this_file: .github/workflows/coverage.yml
name: Code Coverage

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install maturin pytest pytest-cov

      - name: Build extension
        run: maturin develop

      - name: Generate Rust coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path rust-lcov.info

      - name: Generate Python coverage
        run: pytest tests/ --cov=vexy_glob --cov-report=lcov:python-lcov.info

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./rust-lcov.info,./python-lcov.info
          flags: unittests
          name: vexy_glob-coverage
          fail_ci_if_error: false

</document_content>
</document>

<document index="5">
<source>.github/workflows/dependencies.yml</source>
<document_content>
# this_file: .github/workflows/dependencies.yml
name: Update Dependencies

on:
  schedule:
    # Run at 2 AM UTC every Monday
    - cron: '0 2 * * 1'
  workflow_dispatch:

jobs:
  update-rust-dependencies:
    name: Update Rust Dependencies
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Update Cargo.lock
      run: |
        cargo update
        cargo tree
    
    - name: Run tests
      run: cargo test
    
    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v7
      with:
        commit-message: "chore: update Rust dependencies"
        title: "chore: update Rust dependencies"
        body: |
          This PR updates the Rust dependencies in Cargo.lock.
          
          Please review the changes and ensure all tests pass before merging.
        branch: update-rust-dependencies
        delete-branch: true
</document_content>
</document>

<document index="6">
<source>.github/workflows/release.yml</source>
<document_content>
# this_file: .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Extract version from tag
      id: version
      run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
    
    - name: Extract changelog for version
      id: changelog
      run: |
        # Extract the changelog section for this version
        awk '/^## \['${{ steps.version.outputs.VERSION }}'\]/{flag=1; next} /^## \[/{flag=0} flag' CHANGELOG.md > release_notes.md || echo "No changelog found for version ${{ steps.version.outputs.VERSION }}" > release_notes.md
        echo "Release notes:"
        cat release_notes.md
    
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        draft: false
        prerelease: ${{ contains(github.ref, 'rc') || contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
</document_content>
</document>

<document index="7">
<source>.gitignore</source>
<document_content>
# this_file: .gitignore

# Rust
/target
Cargo.lock
*.rs.bk

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/
.nox/
.hypothesis/

# Documentation
docs/_build/
site/

# Other
*.log
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/

vexy_glob/_version.py
/ref
/issues
test_gitignore/test_gitignore/

_version.py
</document_content>
</document>

<document index="8">
<source>AGENTS.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

`vexy_glob` (Path Accelerated Finding in Rust) is a high-performance Python-Rust extension that provides dramatically faster file system traversal and content searching compared to Python's built-in `glob` and `pathlib` modules. It wraps the Rust crates `fd` (ignore) and `ripgrep` (grep-searcher) functionality with a Pythonic API.

Key performance goals:
- 10-100x faster than Python stdlib for file finding
- Stream first results in <5ms (vs 500ms+ for stdlib)
- Constant memory usage regardless of result count
- Full CPU parallelization

## 2. Development Commands

### 2.1. Setting Up the Project
```bash
# Initial setup for Python-Rust extension
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add maturin pyo3 pytest fire rich loguru
uv sync

# Install Rust toolchain if not present
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### 2.2. Building the Extension
```bash
# Development build
maturin develop

# Release build with optimizations
maturin develop --release

# Build wheel for distribution
maturin build --release
```

### 2.3. Running Tests
```bash
# Run Python tests
python -m pytest tests/ -v

# Run Rust tests
cargo test

# Run benchmarks against stdlib
python -m pytest tests/benchmarks/ -v --benchmark-only
```

### 2.4. Code Quality
```bash
# Python linting and formatting
fd -e py -x uvx autoflake -i {}
fd -e py -x uvx pyupgrade --py312-plus {}
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}

# Rust linting and formatting
cargo fmt
cargo clippy -- -D warnings
```

## 3. Architecture Overview

### 3.1. Core Components

1. **Rust Extension Module** (`src/lib.rs`)
   - PyO3 bindings exposing `find()` function to Python
   - Producer-consumer architecture using crossbeam-channel
   - Wrapper around `ignore` crate for traversal and `grep-searcher` for content search

2. **Python API** (`vexy_glob/__init__.py`)
   - Main entry point: `vexy_glob.find(pattern, content=None, root=".", **options)`
   - Iterator-based streaming API with optional list materialization
   - Exception hierarchy: `VexyGlobError`, `PatternError`, `SearchError`, `TraversalNotSupportedError`

3. **Key Design Decisions**
   - **Depth-first traversal only** - Breadth-first causes memory explosion with gitignore files
   - **GIL release during Rust operations** - Enables true parallelism
   - **Streaming by default** - Results yielded as discovered via crossbeam channels
   - **Smart defaults** - Respects .gitignore, skips hidden files unless specified

### 3.2. Critical Implementation Details

1. **Pattern Matching**
   - Uses `globset` crate for efficient glob patterns
   - Case-insensitive by default unless pattern contains uppercase
   - Supports advanced patterns: `**/*.py`, `{src,tests}/**/*.rs`

2. **Content Search**
   - Optional regex search within files using `grep-regex`
   - Binary file detection using NUL byte heuristic
   - SIMD optimizations via Teddy algorithm for multi-pattern matching

3. **Performance Optimizations**
   - Zero-copy operations using Rust `Path`/`PathBuf`
   - Thread pool tuning based on I/O vs CPU workload
   - Buffer sizes: 8KB for traversal, 64KB-256KB for content search

## 4. Development Workflow

1. **File Path Tracking**: All source files must include `# this_file: path/to/file` comment
2. **Documentation**: Maintain WORK.md, PLAN.md, TODO.md, and CHANGELOG.md
3. **Incremental Development**: Focus on minimal viable increments
4. **Testing**: Write tests for all new functionality, especially performance benchmarks

## 5. Common Tasks

### 5.1. Adding a New Option
1. Add parameter to Rust `FindOptions` struct
2. Update PyO3 binding in `find()` function signature
3. Add Python API parameter with appropriate default
4. Update tests and documentation

### 5.2. Debugging Performance
1. Use `cargo flamegraph` for Rust profiling
2. Python `cProfile` for API overhead analysis
3. Compare against baseline benchmarks in `tests/benchmarks/`

### 5.3. Releasing
1. Update version in `Cargo.toml` and `pyproject.toml`
2. Run full test suite including benchmarks
3. Build wheels: `maturin build --release --strip`
4. Upload to PyPI: `maturin publish`

## 6. Important Constraints

- Must maintain Python 3.8+ compatibility
- No external runtime dependencies (all Rust compiled into extension)
- Cross-platform support required (Linux, macOS, Windows)
- API must remain drop-in compatible with `glob.glob()` basic usage


--- 

# Software Development Rules

## 7. Pre-Work Preparation

### 7.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 7.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 8. General Coding Principles

### 8.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 8.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 9. Tool Usage (When Available)

### 9.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 10. File Management

### 10.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 11. Python-Specific Guidelines

### 11.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 11.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 11.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 11.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 12. Post-Work Activities

### 12.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 12.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 13. Work Methodology

### 13.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 13.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 14. Special Commands

### 14.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 14.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 14.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 15. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 16. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate



</document_content>
</document>

<document index="9">
<source>CHANGELOG.md</source>
<document_content>
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- **Comprehensive Documentation** (Issue #102) ✅
  - Expanded README.md from 419 to 1464 lines (3.5x increase)
  - Added architecture diagram showing Rust/Python integration
  - Created complete API reference with all function parameters and types
  - Added extensive cookbook section with 15+ real-world examples
  - Included detailed filtering documentation for size, time, and patterns
  - Expanded CLI documentation with advanced Unix pipeline patterns
  - Added migration guides from glob and pathlib
  - Created platform-specific sections for Windows, macOS, and Linux
  - Added performance tuning guide with optimization tips
  - Included comprehensive FAQ and troubleshooting sections
  - Added acknowledgments and related projects section

### Changed
- **Build System Modernization** ✅
  - Switched from hatch to maturin as primary build backend
  - Configured setuptools-scm for git-tag-based versioning
  - Created sync_version.py script for Cargo.toml version synchronization
  - Updated CI/CD workflows to use maturin directly
  - Created build.sh convenience script for release builds

### Fixed
- **PyO3 0.25 Compatibility** ✅
  - Updated pymodule function signature to use `&Bound<'_, PyModule>`
  - Fixed `add_function` and `add_class` method calls
  - Replaced deprecated `into_py` with `into_pyobject` trait method
  - Replaced `to_object` with `into()` conversion
  - Added explicit type annotations for PyObject conversions
  - Successfully builds with PyO3 0.25 and `uv sync`
- **Build System Duplicate Wheel Issue** ✅
  - Fixed issue where hatch was creating duplicate dev wheels
  - Switched to maturin as the build backend
  - Configured setuptools-scm for git-tag-based versioning
  - Created sync_version.py script for Cargo.toml synchronization
  - Updated CI/CD to use maturin directly
  - Created build.sh script for consistent builds

- Initial project structure and configuration with Rust and Python components
- Complete Rust library with PyO3 bindings for high-performance file finding
- Integration with `ignore` crate for parallel, gitignore-aware directory traversal
- Integration with `globset` crate for efficient glob pattern matching
- **COMPLETE: Content search functionality using `grep-searcher` and `grep-regex` crates** ✅
- Python API wrapper with pathlib integration and drop-in glob compatibility
- Streaming iterator implementation using crossbeam channels for constant memory usage
- Custom exception hierarchy: VexyGlobError, PatternError, SearchError, TraversalNotSupportedError
- Comprehensive test suite with 42 tests covering all major functionality (up from 27)
- Benchmark suite comparing performance against Python's stdlib glob
- **CI/CD Infrastructure**:
  - GitHub Actions workflow for multi-platform testing and builds
  - Cross-platform wheel building with cibuildwheel
  - Automated release workflow for GitHub and PyPI
  - Dependabot configuration for dependency updates
  - Code coverage reporting with codecov integration
  - Contributing guidelines documentation
- Support for:
  - Fast file finding with glob patterns (1.8x faster than stdlib)
    - Gitignore file respect (when in git repositories)
  - Hidden file filtering
  - File type filtering (files, directories, symlinks)
  - Extension filtering
  - Max depth control
  - Streaming results (10x faster time to first result)
  - Path object vs string return types
  - Parallel execution using multiple CPU cores
  - Drop-in replacement functions: `glob()` and `iglob()`

### Changed
- N/A

### Fixed
- N/A

### Performance
- 1.8x faster than stdlib glob for Python file finding
- 10x faster time to first result due to streaming architecture
- Constant memory usage regardless of result count
- Full CPU parallelization with work-stealing algorithms

## [1.0.3] - 2024-08-03

### Added
- **Command-Line Interface (CLI)** ✅
  - `vexy_glob find` command for finding files with all Python API features
  - `vexy_glob search` command for content searching with grep-like output  
  - Human-readable size parsing (10k, 1M, 1G format)
  - Colored output using rich library with match highlighting
  - `--no-color` option for non-interactive usage and pipelines
  - Broken pipe handling for Unix pipeline compatibility
  - Comprehensive CLI test suite with 100+ tests
- **Advanced Filtering Features** ✅
  - File size filtering with `min_size` and `max_size` parameters
  - Modification time filtering with `mtime_after` and `mtime_before` parameters
  - Access time filtering with `atime_after` and `atime_before` parameters
  - Creation time filtering with `ctime_after` and `ctime_before` parameters
  - Human-readable time format support:
    - Relative time: `-1d`, `-2h`, `-30m`, `-45s`
    - ISO dates: `2024-01-01`, `2024-01-01T12:00:00`
    - Python datetime objects
    - Unix timestamps
  - Exclude patterns for sophisticated filtering
  - Custom ignore file support (.ignore, .fdignore)
  - Follow symlinks option with loop detection
- **Content Search Functionality** ✅
  - Ripgrep-style content searching with regex patterns
  - Structured search results with file path, line number, line text, and matches
  - Content search through `find(content="pattern")` and dedicated `search()` function
  - Binary file detection and graceful skipping
  - Case sensitivity controls for content search

### Fixed
- **PyO3 0.25 Compatibility** ✅
  - Updated pymodule function signature to use `&Bound<'_, PyModule>`
  - Fixed `add_function` and `add_class` method calls
  - Replaced deprecated `into_py` with `into_pyobject` trait method
  - Replaced `to_object` with `into()` conversion
  - Added explicit type annotations for PyObject conversions

## [1.0.0] - 2024-07-15

### Added
</document_content>
</document>

<document index="10">
<source>CLAUDE.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

`vexy_glob` (Path Accelerated Finding in Rust) is a high-performance Python-Rust extension that provides dramatically faster file system traversal and content searching compared to Python's built-in `glob` and `pathlib` modules. It wraps the Rust crates `fd` (ignore) and `ripgrep` (grep-searcher) functionality with a Pythonic API.

Key performance goals:
- 10-100x faster than Python stdlib for file finding
- Stream first results in <5ms (vs 500ms+ for stdlib)
- Constant memory usage regardless of result count
- Full CPU parallelization

## 2. Development Commands

### 2.1. Setting Up the Project
```bash
# Initial setup for Python-Rust extension
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add maturin pyo3 pytest fire rich loguru
uv sync

# Install Rust toolchain if not present
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### 2.2. Building the Extension
```bash
# Development build
maturin develop

# Release build with optimizations
maturin develop --release

# Build wheel for distribution
maturin build --release
```

### 2.3. Running Tests
```bash
# Run Python tests
python -m pytest tests/ -v

# Run Rust tests
cargo test

# Run benchmarks against stdlib
python -m pytest tests/benchmarks/ -v --benchmark-only
```

### 2.4. Code Quality
```bash
# Python linting and formatting
fd -e py -x uvx autoflake -i {}
fd -e py -x uvx pyupgrade --py312-plus {}
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}

# Rust linting and formatting
cargo fmt
cargo clippy -- -D warnings
```

## 3. Architecture Overview

### 3.1. Core Components

1. **Rust Extension Module** (`src/lib.rs`)
   - PyO3 bindings exposing `find()` function to Python
   - Producer-consumer architecture using crossbeam-channel
   - Wrapper around `ignore` crate for traversal and `grep-searcher` for content search

2. **Python API** (`vexy_glob/__init__.py`)
   - Main entry point: `vexy_glob.find(pattern, content=None, root=".", **options)`
   - Iterator-based streaming API with optional list materialization
   - Exception hierarchy: `VexyGlobError`, `PatternError`, `SearchError`, `TraversalNotSupportedError`

3. **Key Design Decisions**
   - **Depth-first traversal only** - Breadth-first causes memory explosion with gitignore files
   - **GIL release during Rust operations** - Enables true parallelism
   - **Streaming by default** - Results yielded as discovered via crossbeam channels
   - **Smart defaults** - Respects .gitignore, skips hidden files unless specified

### 3.2. Critical Implementation Details

1. **Pattern Matching**
   - Uses `globset` crate for efficient glob patterns
   - Case-insensitive by default unless pattern contains uppercase
   - Supports advanced patterns: `**/*.py`, `{src,tests}/**/*.rs`

2. **Content Search**
   - Optional regex search within files using `grep-regex`
   - Binary file detection using NUL byte heuristic
   - SIMD optimizations via Teddy algorithm for multi-pattern matching

3. **Performance Optimizations**
   - Zero-copy operations using Rust `Path`/`PathBuf`
   - Thread pool tuning based on I/O vs CPU workload
   - Buffer sizes: 8KB for traversal, 64KB-256KB for content search

## 4. Development Workflow

1. **File Path Tracking**: All source files must include `# this_file: path/to/file` comment
2. **Documentation**: Maintain WORK.md, PLAN.md, TODO.md, and CHANGELOG.md
3. **Incremental Development**: Focus on minimal viable increments
4. **Testing**: Write tests for all new functionality, especially performance benchmarks

## 5. Common Tasks

### 5.1. Adding a New Option
1. Add parameter to Rust `FindOptions` struct
2. Update PyO3 binding in `find()` function signature
3. Add Python API parameter with appropriate default
4. Update tests and documentation

### 5.2. Debugging Performance
1. Use `cargo flamegraph` for Rust profiling
2. Python `cProfile` for API overhead analysis
3. Compare against baseline benchmarks in `tests/benchmarks/`

### 5.3. Releasing
1. Update version in `Cargo.toml` and `pyproject.toml`
2. Run full test suite including benchmarks
3. Build wheels: `maturin build --release --strip`
4. Upload to PyPI: `maturin publish`

## 6. Important Constraints

- Must maintain Python 3.8+ compatibility
- No external runtime dependencies (all Rust compiled into extension)
- Cross-platform support required (Linux, macOS, Windows)
- API must remain drop-in compatible with `glob.glob()` basic usage


--- 

# Software Development Rules

## 7. Pre-Work Preparation

### 7.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 7.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 8. General Coding Principles

### 8.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 8.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 9. Tool Usage (When Available)

### 9.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 10. File Management

### 10.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 11. Python-Specific Guidelines

### 11.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 11.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 11.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 11.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 12. Post-Work Activities

### 12.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 12.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 13. Work Methodology

### 13.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 13.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 14. Special Commands

### 14.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 14.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 14.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 15. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 16. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate



</document_content>
</document>

<document index="11">
<source>CONTRIBUTING.md</source>
<document_content>
# Contributing to vexy_glob

Thank you for your interest in contributing to vexy_glob! This document provides guidelines for contributing to the project.

## Development Setup

### Prerequisites

1. **Python 3.8+**: Install via your package manager or from python.org
2. **Rust**: Install from https://rustup.rs/
3. **uv**: Install with `curl -LsSf https://astral.sh/uv/install.sh | sh`

### Setting Up the Development Environment

```bash
# Clone the repository
git clone https://github.com/yourusername/vexy_glob.git
cd vexy_glob

# Create virtual environment and install dependencies
uv venv --python 3.12
uv sync

# Build the Rust extension in development mode
maturin develop

# Run tests to verify setup
python -m pytest tests/ -v
```

## Development Workflow

### Running Tests

```bash
# Run all tests
python -m pytest tests/ -v

# Run specific test file
python -m pytest tests/test_basic.py -v

# Run with coverage
python -m pytest tests/ --cov=vexy_glob --cov-report=html

# Run Rust tests
cargo test

# Run benchmarks
python -m pytest tests/test_benchmarks.py -v --benchmark-only
```

### Code Quality

Before submitting a PR, ensure your code passes all quality checks:

```bash
# Python formatting and linting
fd -e py -x uvx autoflake -i {}
fd -e py -x uvx pyupgrade --py312-plus {}
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}

# Rust formatting and linting
cargo fmt
cargo clippy -- -D warnings
```

### Building Wheels

```bash
# Build wheel for current platform
maturin build --release

# Build universal wheel (requires multiple Python versions)
maturin build --release --universal2
```

## Making Changes

### Code Style

- **Python**: Follow PEP 8, use type hints, write clear docstrings
- **Rust**: Follow standard Rust conventions, use `cargo fmt`
- **Comments**: Explain WHY, not just WHAT
- **File paths**: Include `# this_file: path/to/file` comment in all source files

### Commit Messages

Follow conventional commit format:
- `feat:` New features
- `fix:` Bug fixes
- `docs:` Documentation changes
- `test:` Test additions/changes
- `chore:` Maintenance tasks
- `perf:` Performance improvements

Example: `feat: add content search functionality with regex support`

### Pull Request Process

1. Fork the repository and create a feature branch
2. Make your changes following the guidelines above
3. Add tests for new functionality
4. Update documentation as needed
5. Ensure all tests pass locally
6. Submit a PR with a clear description

### Testing Guidelines

- Write tests for all new functionality
- Include edge cases and error conditions
- Use descriptive test names
- Keep tests focused and independent
- Add benchmarks for performance-critical code

## Architecture Overview

### Rust Side (`src/`)
- `lib.rs`: Main PyO3 module and Python bindings
- Core functionality using `ignore` and `globset` crates
- Content search using `grep-searcher` and `grep-regex`
- Producer-consumer pattern with crossbeam channels

### Python Side (`vexy_glob/`)
- `__init__.py`: Public API and convenience functions
- Exception hierarchy for error handling
- Type hints and comprehensive docstrings

## Performance Considerations

When contributing performance improvements:
1. Always benchmark before and after changes
2. Use the existing benchmark suite as a baseline
3. Consider memory usage, not just speed
4. Document performance characteristics

## Getting Help

- Open an issue for bugs or feature requests
- Start a discussion for design decisions
- Check existing issues before creating new ones

## License

By contributing to vexy_glob, you agree that your contributions will be licensed under the MIT License.
</document_content>
</document>

<document index="12">
<source>Cargo.toml</source>
<document_content>
[package]
name = "vexy_glob"
version = "1.0.3"
authors = ["Fontlab Ltd. <opensource@vexy.art>"]
edition = "2021"
description = "Vexy Glob fast file finding for Python"
readme = "README.md"
repository = "https://github.com/vexyart/vexy-glob"
license = "MIT"
keywords = ["filesystem", "find", "glob", "parallel", "search"]
categories = ["command-line-utilities", "filesystem"]

[lib]
crate-type = ["cdylib"]
name = "vexy_glob"

[dependencies]
anyhow = "1.0"
crossbeam-channel = "0.5"
globset = "0.4"
grep-matcher = "0.1"
grep-regex = "0.1"
grep-searcher = "0.1"
ignore = "0.4"
num_cpus = "1.16"
pyo3 = { version = "0.25", features = ["abi3-py38", "extension-module"] }
rayon = "1.8"
regex = "1.10"
walkdir = "2.4"

[profile.release]
opt-level = 3
strip = true
lto = true
panic = "abort"
codegen-units = 1


</document_content>
</document>

<document index="13">
<source>GEMINI.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

`vexy_glob` (Path Accelerated Finding in Rust) is a high-performance Python-Rust extension that provides dramatically faster file system traversal and content searching compared to Python's built-in `glob` and `pathlib` modules. It wraps the Rust crates `fd` (ignore) and `ripgrep` (grep-searcher) functionality with a Pythonic API.

Key performance goals:
- 10-100x faster than Python stdlib for file finding
- Stream first results in <5ms (vs 500ms+ for stdlib)
- Constant memory usage regardless of result count
- Full CPU parallelization

## 2. Development Commands

### 2.1. Setting Up the Project
```bash
# Initial setup for Python-Rust extension
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add maturin pyo3 pytest fire rich loguru
uv sync

# Install Rust toolchain if not present
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### 2.2. Building the Extension
```bash
# Development build
maturin develop

# Release build with optimizations
maturin develop --release

# Build wheel for distribution
maturin build --release
```

### 2.3. Running Tests
```bash
# Run Python tests
python -m pytest tests/ -v

# Run Rust tests
cargo test

# Run benchmarks against stdlib
python -m pytest tests/benchmarks/ -v --benchmark-only
```

### 2.4. Code Quality
```bash
# Python linting and formatting
fd -e py -x uvx autoflake -i {}
fd -e py -x uvx pyupgrade --py312-plus {}
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}

# Rust linting and formatting
cargo fmt
cargo clippy -- -D warnings
```

## 3. Architecture Overview

### 3.1. Core Components

1. **Rust Extension Module** (`src/lib.rs`)
   - PyO3 bindings exposing `find()` function to Python
   - Producer-consumer architecture using crossbeam-channel
   - Wrapper around `ignore` crate for traversal and `grep-searcher` for content search

2. **Python API** (`vexy_glob/__init__.py`)
   - Main entry point: `vexy_glob.find(pattern, content=None, root=".", **options)`
   - Iterator-based streaming API with optional list materialization
   - Exception hierarchy: `VexyGlobError`, `PatternError`, `SearchError`, `TraversalNotSupportedError`

3. **Key Design Decisions**
   - **Depth-first traversal only** - Breadth-first causes memory explosion with gitignore files
   - **GIL release during Rust operations** - Enables true parallelism
   - **Streaming by default** - Results yielded as discovered via crossbeam channels
   - **Smart defaults** - Respects .gitignore, skips hidden files unless specified

### 3.2. Critical Implementation Details

1. **Pattern Matching**
   - Uses `globset` crate for efficient glob patterns
   - Case-insensitive by default unless pattern contains uppercase
   - Supports advanced patterns: `**/*.py`, `{src,tests}/**/*.rs`

2. **Content Search**
   - Optional regex search within files using `grep-regex`
   - Binary file detection using NUL byte heuristic
   - SIMD optimizations via Teddy algorithm for multi-pattern matching

3. **Performance Optimizations**
   - Zero-copy operations using Rust `Path`/`PathBuf`
   - Thread pool tuning based on I/O vs CPU workload
   - Buffer sizes: 8KB for traversal, 64KB-256KB for content search

## 4. Development Workflow

1. **File Path Tracking**: All source files must include `# this_file: path/to/file` comment
2. **Documentation**: Maintain WORK.md, PLAN.md, TODO.md, and CHANGELOG.md
3. **Incremental Development**: Focus on minimal viable increments
4. **Testing**: Write tests for all new functionality, especially performance benchmarks

## 5. Common Tasks

### 5.1. Adding a New Option
1. Add parameter to Rust `FindOptions` struct
2. Update PyO3 binding in `find()` function signature
3. Add Python API parameter with appropriate default
4. Update tests and documentation

### 5.2. Debugging Performance
1. Use `cargo flamegraph` for Rust profiling
2. Python `cProfile` for API overhead analysis
3. Compare against baseline benchmarks in `tests/benchmarks/`

### 5.3. Releasing
1. Update version in `Cargo.toml` and `pyproject.toml`
2. Run full test suite including benchmarks
3. Build wheels: `maturin build --release --strip`
4. Upload to PyPI: `maturin publish`

## 6. Important Constraints

- Must maintain Python 3.8+ compatibility
- No external runtime dependencies (all Rust compiled into extension)
- Cross-platform support required (Linux, macOS, Windows)
- API must remain drop-in compatible with `glob.glob()` basic usage


--- 

# Software Development Rules

## 7. Pre-Work Preparation

### 7.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 7.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 8. General Coding Principles

### 8.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 8.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 9. Tool Usage (When Available)

### 9.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 10. File Management

### 10.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 11. Python-Specific Guidelines

### 11.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 11.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 11.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 11.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 12. Post-Work Activities

### 12.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 12.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 13. Work Methodology

### 13.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 13.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 14. Special Commands

### 14.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 14.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 14.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 15. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 16. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate



</document_content>
</document>

<document index="14">
<source>LICENSE</source>
<document_content>
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

</document_content>
</document>

<document index="15">
<source>PLAN.md</source>
<document_content>
# PLAN.md - vexy_glob: Path Accelerated Finding in Rust

## Project Overview

`vexy_glob` is a high-performance Python extension written in Rust that provides dramatically faster file system traversal and content searching compared to Python's built-in `glob` and `pathlib` modules. By leveraging the same Rust crates that power `fd` and `ripgrep`, vexy_glob delivers significant performance improvements while maintaining a Pythonic API.

**Current Status: PRODUCTION READY** 🚀

- 1.8x faster than stdlib for file finding
- 10x faster time to first result with streaming
- 99+ tests passing with 97% code coverage
- Content search functionality complete
- CI/CD infrastructure deployed
- File size and time filtering implemented
- Human-readable time formats supported
- CLI implementation complete
- Build system modernized with hatch
- PyO3 0.25 compatibility fixed

### Core Objectives - Achievement Status

1. **Performance**: ✅ ACHIEVED - 1.8x overall speedup, 10x streaming speedup
2. **Streaming**: ✅ ACHIEVED - First results in ~3ms vs 30ms+ for stdlib
3. **Memory Efficiency**: ✅ ACHIEVED - Constant memory with bounded channels
4. **Parallelism**: ✅ ACHIEVED - Full CPU utilization with ignore crate
5. **Pythonic API**: ✅ ACHIEVED - Drop-in glob/iglob compatibility
6. **Cross-Platform**: ✅ ACHIEVED - CI/CD configured for Windows, Linux, macOS
7. **Zero Dependencies**: ✅ ACHIEVED - Self-contained binary wheel
8. **Content Search**: ✅ ACHIEVED - Full ripgrep-style functionality
9. **CI/CD Pipeline**: ✅ ACHIEVED - GitHub Actions with multi-platform builds

## Technical Architecture

### Core Technology Stack

- **Rust Extension**: PyO3 for Python bindings with zero-copy operations
- **Directory Traversal**: `ignore` crate for parallel, gitignore-aware walking
- **Pattern Matching**: `globset` crate for efficient glob compilation
- **Content Search**: `grep-searcher` and `grep-regex` for high-performance text search
- **Parallelism**: `rayon` for work-stealing parallelism, `crossbeam-channel` for streaming
- **Build System**: `maturin` for building and distributing wheels

### Key Design Decisions

1. **Depth-First Only**: Based on ignore crate's architecture and performance characteristics
2. **GIL Release**: All Rust operations run without GIL for true parallelism
3. **Channel-Based Streaming**: Producer-consumer pattern with bounded channels
4. **Smart Defaults**: Respect .gitignore, skip hidden files unless specified
5. **Zero-Copy Path Handling**: Minimize allocations for path operations

## Implementation Progress

### 🔄 REMAINING PHASES

#### Phase 8: Advanced Features - Partially Complete

Remaining filtering and optimization features:

##### 8.1 Advanced Options

- [ ] Add same_file_system option to prevent crossing mount points

##### 8.2 Performance Optimizations

- [ ] Add result sorting options (name, size, mtime)
- [ ] Implement smart-case matching optimization
- [ ] Add literal string optimization paths
- [ ] Configure optimal buffer sizes for different workloads
- [ ] Optimize hot paths based on profiling

#### Phase 9: Platform Testing and Validation

Cross-platform testing and compatibility:

##### 9.1 Platform-Specific Testing

- [ ] Test and fix Windows-specific path handling
- [ ] Verify Linux compatibility across distributions
- [ ] Test macOS-specific features (e.g., .DS_Store handling)
- [ ] Handle platform-specific file system features
- [ ] Test performance across different platforms
- [ ] Verify Unicode path handling on all platforms

##### 9.2 Integration Testing

- [ ] Test with real-world codebases
- [ ] Benchmark against fd and ripgrep directly
- [ ] Test with extremely large directories (1M+ files)
- [ ] Verify memory usage stays constant
- [ ] Test interruption and cleanup behavior

#### Phase 10: Release Preparation

Final testing and PyPI release:

##### 10.1 Final Testing

- [ ] Run full test suite on all platforms via CI
- [ ] Manual testing on Windows, Linux, macOS
- [ ] Test installation from wheels on clean systems
- [ ] Verify all examples work correctly
- [ ] Performance regression testing

##### 10.2 Release Process

- [ ] Update version to 1.0.0
- [ ] Create comprehensive release notes
- [ ] Build wheels for all platforms
- [ ] Publish to Test PyPI
- [ ] Test installation from Test PyPI
- [ ] Publish to PyPI
- [ ] Create GitHub release with artifacts
- [ ] Announce on Python forums and social media

## API Specification

### Core Functions

```python
def find(
    pattern: str = "*",
    root: Union[str, Path] = ".",
    *,
    content: Optional[str] = None,
    file_type: Optional[str] = None,
    extension: Optional[Union[str, List[str]]] = None,
    max_depth: Optional[int] = None,
    min_depth: int = 0,
    min_size: Optional[int] = None,
    max_size: Optional[int] = None,
    mtime_after: Optional[Union[float, int, str, datetime]] = None,
    mtime_before: Optional[Union[float, int, str, datetime]] = None,
    hidden: bool = False,
    ignore_git: bool = False,
    case_sensitive: Optional[bool] = None,  # None = smart case
    follow_symlinks: bool = False,
    threads: Optional[int] = None,
    as_path: bool = False,
    as_list: bool = False,
) -> Union[Iterator[Union[str, Path]], List[Union[str, Path]]]:
    """Fast file finding with optional content search."""

def glob(pattern: str, *, recursive: bool = False, root_dir: Optional[str] = None, **kwargs) -> List[str]:
    """Drop-in replacement for glob.glob()."""

def iglob(pattern: str, *, recursive: bool = False, root_dir: Optional[str] = None, **kwargs) -> Iterator[str]:
    """Drop-in replacement for glob.iglob()."""

def search(
    content_regex: str,
    pattern: str = "*",
    root: Union[str, Path] = ".",
    **kwargs
) -> Union[Iterator[SearchResult], List[SearchResult]]:
    """Search for content within files using regex patterns."""
```

### Exception Hierarchy

```python
class VexyGlobError(Exception):
    """Base exception for all vexy_glob errors."""

class PatternError(VexyGlobError, ValueError):
    """Invalid glob or regex pattern."""

class SearchError(VexyGlobError, IOError):
    """I/O or permission error during search."""

class TraversalNotSupportedError(VexyGlobError, NotImplementedError):
    """Requested traversal method not supported."""
```

## Performance Targets

| Operation | Python stdlib | vexy_glob Target | Expected Improvement |
| --- | --- | --- | --- |
| Small dir glob (100 files) | 5ms | 0.5ms | 10x |
| Medium dir recursive (10K files) | 500ms | 25ms | 20x |
| Large dir recursive (100K files) | 15s | 200ms | 75x |
| Time to first result | 500ms+ | <5ms | 100x+ |
| Memory usage (1M files) | 1GB+ | <100MB | 10x+ |

## Risk Mitigation

1. **Breadth-First Limitation**: Clearly document DFS-only design with rationale
2. **Binary File Handling**: Implement robust detection and graceful skipping
3. **Path Encoding**: Handle all platform-specific path encodings correctly
4. **Memory Pressure**: Use bounded channels and backpressure mechanisms
5. **Error Recovery**: Implement comprehensive error handling and recovery

## Future Enhancements

1. **Persistent Cache**: Optional directory index for repeated searches
2. **Watch Mode**: Integration with filesystem notification APIs
3. **Cloud Storage**: Support for S3-compatible object stores
4. **Advanced Patterns**: Support for more complex path expressions
5. **IDE Integration**: Language server protocol support

## Success Metrics

1. **Performance**: Meet or exceed all performance targets
2. **Compatibility**: Pass all cross-platform tests
3. **Adoption**: 1000+ downloads in first month
4. **Stability**: <5 bug reports per 1000 users
5. **Documentation**: >90% API coverage with examples

</document_content>
</document>

<document index="16">
<source>README.md</source>
<document_content>
# vexy_glob - Path Accelerated Finding in Rust

[![PyPI version](https://badge.fury.io/py/vexy_glob.svg)](https://badge.fury.io/py/vexy_glob) [![CI](https://github.com/vexyart/vexy-glob/actions/workflows/ci.yml/badge.svg)](https://github.com/vexyart/vexy-glob/actions/workflows/ci.yml) [![codecov](https://codecov.io/gh/vexyart/vexy-glob/branch/main/graph/badge.svg)](https://codecov.io/gh/vexyart/vexy-glob)

**`vexy_glob`** is a high-performance Python extension for file system traversal and content searching, built with Rust. It provides a faster and more feature-rich alternative to Python's built-in `glob` (up to 6x faster) and `pathlib` (up to 12x faster) modules.

## TL;DR

**Installation:**

```bash
pip install vexy_glob
```

**Quick Start:**

Find all Python files in the current directory and its subdirectories:

```python
import vexy_glob

for path in vexy_glob.find("**/*.py"):
    print(path)
```

Find all files containing the text "import asyncio":

```python
for match in vexy_glob.find("**/*.py", content="import asyncio"):
    print(f"{match.path}:{match.line_number}: {match.line_text}")
```

## What is `vexy_glob`?

`vexy_glob` is a Python library that provides a powerful and efficient way to find files and search for content within them. It's built on top of the excellent Rust crates `ignore` (for file traversal) and `grep-searcher` (for content searching), which are the same engines powering tools like `fd` and `ripgrep`.

This means you get the speed and efficiency of Rust, with the convenience and ease of use of Python.

### Architecture Overview

```
┌─────────────────────┐
│   Python API Layer  │  ← Your Python code calls vexy_glob.find()
├─────────────────────┤
│    PyO3 Bindings    │  ← Zero-copy conversions between Python/Rust
├─────────────────────┤
│  Rust Core Engine   │  ← GIL released for true parallelism
│  ┌───────────────┐  │
│  │ ignore crate  │  │  ← Parallel directory traversal
│  │ (from fd)     │  │     Respects .gitignore files
│  └───────────────┘  │
│  ┌───────────────┐  │
│  │ grep-searcher │  │  ← High-speed content search
│  │ (from ripgrep)│  │     SIMD-accelerated regex
│  └───────────────┘  │
├─────────────────────┤
│ Streaming Channel   │  ← Results yielded as found
│ (crossbeam-channel) │     No memory accumulation
└─────────────────────┘
```

## Key Features

- **🚀 Blazing Fast:** 10-100x faster than Python's `glob` and `pathlib` for many use cases.
- **⚡ Streaming Results:** Get the first results in milliseconds, without waiting for the entire file system scan to complete.
- **💾 Memory Efficient:** `vexy_glob` uses constant memory, regardless of the number of files or results.
- **🔥 Parallel Execution:** Utilizes all your CPU cores to get the job done as quickly as possible.
- **🔍 Content Searching:** Ripgrep-style content searching with regex support.
- **🎯 Rich Filtering:** Filter files by size, modification time, and more.
- **🧠 Smart Defaults:** Automatically respects `.gitignore` files and skips hidden files and directories.
- **🌍 Cross-Platform:** Works on Linux, macOS, and Windows.

### Feature Comparison

| Feature | `glob.glob()` | `pathlib` | `vexy_glob` |
| --- | --- | --- | --- |
| Pattern matching | ✅ Basic | ✅ Basic | ✅ Advanced |
| Recursive search | ✅ Slow | ✅ Slow | ✅ Fast |
| Streaming results | ❌ | ❌ | ✅ |
| Content search | ❌ | ❌ | ✅ |
| .gitignore respect | ❌ | ❌ | ✅ |
| Parallel execution | ❌ | ❌ | ✅ |
| Size filtering | ❌ | ❌ | ✅ |
| Time filtering | ❌ | ❌ | ✅ |
| Memory efficiency | ❌ | ❌ | ✅ |

## How it Works

`vexy_glob` uses a Rust-powered backend to perform the heavy lifting of file system traversal and content searching. The Rust extension releases Python's Global Interpreter Lock (GIL), allowing for true parallelism and a significant performance boost.

Results are streamed back to Python as they are found, using a producer-consumer architecture with crossbeam channels. This means you can start processing results immediately, without having to wait for the entire search to finish.

## Why use `vexy_glob`?

If you find yourself writing scripts that need to find files based on patterns, or search for content within files, `vexy_glob` can be a game-changer. It's particularly useful for:

- **Large codebases:** Quickly find files or code snippets in large projects.
- **Log file analysis:** Search through gigabytes of logs in seconds.
- **Data processing pipelines:** Efficiently find and process files based on various criteria.
- **Build systems:** Fast dependency scanning and file collection.
- **Data science:** Quickly locate and process data files.
- **DevOps:** Log analysis, configuration management, deployment scripts.
- **Testing:** Find test files, fixtures, and coverage reports.
- **Anywhere you need to find files fast!**

### When to Use vexy_glob vs Alternatives

| Use Case | Best Tool | Why |
| --- | --- | --- |
| Simple pattern in small directory | `glob.glob()` | Built-in, no dependencies |
| Large directory, need first result fast | `vexy_glob` | Streaming results |
| Search file contents | `vexy_glob` | Integrated content search |
| Complex filtering (size, time, etc.) | `vexy_glob` | Rich filtering API |
| Cross-platform scripts | `vexy_glob` | Consistent behavior |
| Git-aware file finding | `vexy_glob` | Respects .gitignore |
| Memory-constrained environment | `vexy_glob` | Constant memory usage |

## Installation and Usage

### Python Library

Install `vexy_glob` using pip:

```bash
pip install vexy_glob
```

Then use it in your Python code:

```python
import vexy_glob

# Find all Python files
for path in vexy_glob.find("**/*.py"):
    print(path)
```

### Command-Line Interface

`vexy_glob` also provides a powerful command-line interface for finding files and searching content directly from your terminal.

#### Finding Files

Use `vexy_glob find` to locate files matching glob patterns:

```bash
# Find all Python files
vexy_glob find "**/*.py"

# Find all markdown files larger than 10KB
vexy_glob find "**/*.md" --min-size 10k

# Find all log files modified in the last 2 days
vexy_glob find "*.log" --mtime-after -2d

# Find only directories
vexy_glob find "*" --type d

# Include hidden files
vexy_glob find "*" --hidden

# Limit search depth
vexy_glob find "**/*.txt" --depth 2
```

#### Searching Content

Use `vexy_glob search` to find content within files:

```bash
# Search for "import asyncio" in Python files
vexy_glob search "**/*.py" "import asyncio"

# Search for function definitions using regex
vexy_glob search "src/**/*.rs" "fn\\s+\\w+"

# Search without color output (for piping)
vexy_glob search "**/*.md" "TODO|FIXME" --no-color

# Case-sensitive search
vexy_glob search "*.txt" "Error" --case-sensitive

# Search with size filters
vexy_glob search "**/*.log" "ERROR" --min-size 1M --max-size 100M

# Search recent files only
vexy_glob search "**/*.py" "TODO" --mtime-after -7d

# Complex search with multiple filters
vexy_glob search "src/**/*.{py,js}" "console\.log|print\(" \
    --exclude "*test*" \
    --mtime-after -30d \
    --max-size 50k
```

#### Command-Line Options Reference

**Common options for both `find` and `search`:**

| Option | Type | Description | Example |
| --- | --- | --- | --- |
| `--root` | PATH | Root directory to start search | `--root /home/user/projects` |
| `--min-size` | SIZE | Minimum file size | `--min-size 10k` |
| `--max-size` | SIZE | Maximum file size | `--max-size 5M` |
| `--mtime-after` | TIME | Modified after this time | `--mtime-after -7d` |
| `--mtime-before` | TIME | Modified before this time | `--mtime-before 2024-01-01` |
| `--atime-after` | TIME | Accessed after this time | `--atime-after -1h` |
| `--atime-before` | TIME | Accessed before this time | `--atime-before -30d` |
| `--ctime-after` | TIME | Created after this time | `--ctime-after -1w` |
| `--ctime-before` | TIME | Created before this time | `--ctime-before -1y` |
| `--no-gitignore` | FLAG | Don't respect .gitignore | `--no-gitignore` |
| `--hidden` | FLAG | Include hidden files | `--hidden` |
| `--case-sensitive` | FLAG | Force case sensitivity | `--case-sensitive` |
| `--type` | CHAR | File type (f/d/l) | `--type f` |
| `--extension` | STR | File extension(s) | `--extension py` |
| `--exclude` | PATTERN | Exclude patterns | `--exclude "*test*"` |
| `--depth` | INT | Maximum directory depth | `--depth 3` |
| `--follow-symlinks` | FLAG | Follow symbolic links | `--follow-symlinks` |

**Additional options for `search`:**

| Option | Type | Description | Example |
| --- | --- | --- | --- |
| `--no-color` | FLAG | Disable colored output | `--no-color` |

**Size format examples:**
- Bytes: `1024` or `"1024"`
- Kilobytes: `10k`, `10K`, `10kb`, `10KB`
- Megabytes: `5m`, `5M`, `5mb`, `5MB`
- Gigabytes: `2g`, `2G`, `2gb`, `2GB`
- With decimals: `1.5M`, `2.7G`, `0.5K`

**Time format examples:**
- Relative: `-30s`, `-5m`, `-2h`, `-7d`, `-2w`, `-1mo`, `-1y`
- ISO date: `2024-01-01`, `2024-01-01T10:30:00`
- Natural: `yesterday`, `today` (converted to ISO dates)

#### Unix Pipeline Integration

`vexy_glob` works seamlessly with Unix pipelines:

```bash
# Count Python files
vexy_glob find "**/*.py" | wc -l

# Find Python files containing "async" and edit them
vexy_glob search "**/*.py" "async" --no-color | cut -d: -f1 | sort -u | xargs $EDITOR

# Find large log files and show their sizes
vexy_glob find "*.log" --min-size 100M | xargs ls -lh

# Search for TODOs and format as tasks
vexy_glob search "**/*.py" "TODO" --no-color | awk -F: '{print "- [ ] " $1 ":" $2 ": " $3}'

# Find duplicate file names
vexy_glob find "**/*" --type f | xargs -n1 basename | sort | uniq -d

# Create archive of recent changes
vexy_glob find "**/*" --mtime-after -7d --type f | tar -czf recent_changes.tar.gz -T -

# Find and replace across files
vexy_glob search "**/*.py" "OldClassName" --no-color | cut -d: -f1 | sort -u | xargs sed -i 's/OldClassName/NewClassName/g'

# Generate ctags for Python files
vexy_glob find "**/*.py" | ctags -L -

# Find empty directories
vexy_glob find "**" --type d | while read dir; do [ -z "$(ls -A "$dir")" ] && echo "$dir"; done

# Calculate total size of Python files
vexy_glob find "**/*.py" --type f | xargs stat -f%z | awk '{s+=$1} END {print s}' | numfmt --to=iec
```

#### Advanced CLI Patterns

```bash
# Monitor for file changes (poor man's watch)
while true; do
    clear
    echo "Files modified in last minute:"
    vexy_glob find "**/*" --mtime-after -1m --type f
    sleep 10
done

# Parallel processing with GNU parallel
vexy_glob find "**/*.jpg" | parallel -j4 convert {} {.}_thumb.jpg

# Create a file manifest with checksums
vexy_glob find "**/*" --type f | while read -r file; do
    echo "$(sha256sum "$file" | cut -d' ' -f1) $file"
done > manifest.txt

# Find files by content and show context
vexy_glob search "**/*.py" "class.*Error" --no-color | while IFS=: read -r file line rest; do
    echo "\n=== $file:$line ==="
    sed -n "$((line-2)),$((line+2))p" "$file"
done
```

## Detailed Python API Reference

### Core Functions

#### Core Functions

##### `vexy_glob.find()`

The main function for finding files and searching content.

###### Basic Syntax

```python
def find(
    pattern: str = "*",
    root: Union[str, Path] = ".",
    *,
    content: Optional[str] = None,
    file_type: Optional[str] = None,
    extension: Optional[Union[str, List[str]]] = None,
    max_depth: Optional[int] = None,
    min_depth: int = 0,
    min_size: Optional[int] = None,
    max_size: Optional[int] = None,
    mtime_after: Optional[Union[float, int, str, datetime]] = None,
    mtime_before: Optional[Union[float, int, str, datetime]] = None,
    atime_after: Optional[Union[float, int, str, datetime]] = None,
    atime_before: Optional[Union[float, int, str, datetime]] = None,
    ctime_after: Optional[Union[float, int, str, datetime]] = None,
    ctime_before: Optional[Union[float, int, str, datetime]] = None,
    hidden: bool = False,
    ignore_git: bool = False,
    case_sensitive: Optional[bool] = None,
    follow_symlinks: bool = False,
    threads: Optional[int] = None,
    as_path: bool = False,
    as_list: bool = False,
    exclude: Optional[Union[str, List[str]]] = None,
) -> Union[Iterator[Union[str, Path, SearchResult]], List[Union[str, Path, SearchResult]]]:
    """Find files matching pattern with optional content search.
    
    Args:
        pattern: Glob pattern to match files (e.g., "**/*.py", "src/*.js")
        root: Root directory to start search from
        content: Regex pattern to search within files
        file_type: Filter by type - 'f' (file), 'd' (directory), 'l' (symlink)
        extension: File extension(s) to filter by (e.g., "py" or ["py", "pyi"])
        max_depth: Maximum directory depth to search
        min_depth: Minimum directory depth to search
        min_size: Minimum file size in bytes (or use parse_size())
        max_size: Maximum file size in bytes
        mtime_after: Files modified after this time
        mtime_before: Files modified before this time
        atime_after: Files accessed after this time
        atime_before: Files accessed before this time
        ctime_after: Files created after this time
        ctime_before: Files created before this time
        hidden: Include hidden files and directories
        ignore_git: Don't respect .gitignore files
        case_sensitive: Case sensitivity (None = smart case)
        follow_symlinks: Follow symbolic links
        threads: Number of threads (None = auto)
        as_path: Return Path objects instead of strings
        as_list: Return list instead of iterator
        exclude: Patterns to exclude from results
    
    Returns:
        Iterator or list of file paths (or SearchResult if content is specified)
    """
```

##### Basic Examples

```python
import vexy_glob

# Find all Python files
for path in vexy_glob.find("**/*.py"):
    print(path)

# Find all files in the 'src' directory
for path in vexy_glob.find("src/**/*"):
    print(path)

# Get results as a list instead of iterator
python_files = vexy_glob.find("**/*.py", as_list=True)
print(f"Found {len(python_files)} Python files")

# Get results as Path objects
from pathlib import Path
for path in vexy_glob.find("**/*.md", as_path=True):
    print(path.stem)  # Path object methods available
```

### Content Searching

To search for content within files, use the `content` parameter. This will return an iterator of `SearchResult` objects, containing information about each match.

```python
import vexy_glob

for match in vexy_glob.find("*.py", content="import requests"):
    print(f"Found a match in {match.path} on line {match.line_number}:")
    print(f"  {match.line_text.strip()}")
```

#### SearchResult Object

The `SearchResult` object has the following attributes:

- `path`: The path to the file containing the match.
- `line_number`: The line number of the match (1-indexed).
- `line_text`: The text of the line containing the match.
- `matches`: A list of matched strings on the line.

#### Content Search Examples

```python
# Simple text search
for match in vexy_glob.find("**/*.py", content="TODO"):
    print(f"{match.path}:{match.line_number}: {match.line_text.strip()}")

# Regex pattern search
for match in vexy_glob.find("**/*.py", content=r"def\s+\w+\(.*\):"):
    print(f"Function at {match.path}:{match.line_number}")

# Case-insensitive search
for match in vexy_glob.find("**/*.md", content="python", case_sensitive=False):
    print(match.path)

# Multiple pattern search with OR
for match in vexy_glob.find("**/*.py", content="import (os|sys|pathlib)"):
    print(f"{match.path}: imports {match.matches}")
```

### Filtering Options

#### Size Filtering

`vexy_glob` supports human-readable size formats:

```python
import vexy_glob

# Using parse_size() for readable formats
min_size = vexy_glob.parse_size("10K")   # 10 kilobytes
max_size = vexy_glob.parse_size("5.5M")  # 5.5 megabytes

for path in vexy_glob.find("**/*", min_size=min_size, max_size=max_size):
    print(path)

# Supported formats:
# - Bytes: "1024" or 1024
# - Kilobytes: "10K", "10KB", "10k", "10kb"
# - Megabytes: "5M", "5MB", "5m", "5mb"
# - Gigabytes: "2G", "2GB", "2g", "2gb"
# - Decimal: "1.5M", "2.7G"
```

#### Time Filtering

`vexy_glob` accepts multiple time formats:

```python
import vexy_glob
from datetime import datetime, timedelta

# 1. Relative time formats
for path in vexy_glob.find("**/*.log", mtime_after="-1d"):     # Last 24 hours
    print(path)

# Supported relative formats:
# - Seconds: "-30s" or "-30"
# - Minutes: "-5m"
# - Hours: "-2h"
# - Days: "-7d"
# - Weeks: "-2w"
# - Months: "-1mo" (30 days)
# - Years: "-1y" (365 days)

# 2. ISO date formats
for path in vexy_glob.find("**/*", mtime_after="2024-01-01"):
    print(path)

# Supported ISO formats:
# - Date: "2024-01-01"
# - DateTime: "2024-01-01T10:30:00"
# - With timezone: "2024-01-01T10:30:00Z"

# 3. Python datetime objects
week_ago = datetime.now() - timedelta(weeks=1)
for path in vexy_glob.find("**/*", mtime_after=week_ago):
    print(path)

# 4. Unix timestamps
import time
hour_ago = time.time() - 3600
for path in vexy_glob.find("**/*", mtime_after=hour_ago):
    print(path)

# Combining time filters
for path in vexy_glob.find(
    "**/*.py",
    mtime_after="-30d",      # Modified within 30 days
    mtime_before="-1d"       # But not in the last 24 hours
):
    print(path)
```

#### Type and Extension Filtering

```python
import vexy_glob

# Filter by file type
for path in vexy_glob.find("**/*", file_type="d"):  # Directories only
    print(f"Directory: {path}")

# File types:
# - "f": Regular files
# - "d": Directories
# - "l": Symbolic links

# Filter by extension
for path in vexy_glob.find("**/*", extension="py"):
    print(path)

# Multiple extensions
for path in vexy_glob.find("**/*", extension=["py", "pyi", "pyx"]):
    print(path)
```

#### Exclusion Patterns

```python
import vexy_glob

# Exclude single pattern
for path in vexy_glob.find("**/*.py", exclude="*test*"):
    print(path)

# Exclude multiple patterns
exclusions = [
    "**/__pycache__/**",
    "**/node_modules/**",
    "**/.git/**",
    "**/build/**",
    "**/dist/**"
]
for path in vexy_glob.find("**/*", exclude=exclusions):
    print(path)

# Exclude specific files
for path in vexy_glob.find(
    "**/*.py",
    exclude=["setup.py", "**/conftest.py", "**/*_test.py"]
):
    print(path)
```

### Pattern Matching Guide

#### Glob Pattern Syntax

| Pattern | Matches | Example |
| --- | --- | --- |
| `*` | Any characters (except `/`) | `*.py` matches `test.py` |
| `**` | Any characters including `/` | `**/*.py` matches `src/lib/test.py` |
| `?` | Single character | `test?.py` matches `test1.py` |
| `[seq]` | Character in sequence | `test[123].py` matches `test2.py` |
| `[!seq]` | Character not in sequence | `test[!0].py` matches `test1.py` |
| `{a,b}` | Either pattern a or b | `*.{py,js}` matches `.py` and `.js` files |

#### Smart Case Detection

By default, `vexy_glob` uses smart case detection:
- If pattern contains uppercase → case-sensitive
- If pattern is all lowercase → case-insensitive

```python
# Case-insensitive (finds README.md, readme.md, etc.)
vexy_glob.find("readme.md")

# Case-sensitive (only finds README.md)
vexy_glob.find("README.md")

# Force case sensitivity
vexy_glob.find("readme.md", case_sensitive=True)
```

### Drop-in Replacements

`vexy_glob` provides drop-in replacements for standard library functions:

```python
# Replace glob.glob()
import vexy_glob
files = vexy_glob.glob("**/*.py", recursive=True)

# Replace glob.iglob()
for path in vexy_glob.iglob("**/*.py", recursive=True):
    print(path)

# Migration from standard library
# OLD:
import glob
files = glob.glob("**/*.py", recursive=True)

# NEW: Just change the import!
import vexy_glob as glob
files = glob.glob("**/*.py", recursive=True)  # 10-100x faster!
```

## Performance

### Benchmark Results

Benchmarks on a directory with 100,000 files:

| Operation            | `glob.glob()` | `pathlib` | `vexy_glob` | Speedup  |
| -------------------- | ------------- | --------- | ----------- | -------- |
| Find all `.py` files | 15.2s         | 18.1s     | 0.2s        | 76x      |
| Time to first result | 15.2s         | 18.1s     | 0.005s      | 3040x    |
| Memory usage         | 1.2GB         | 1.5GB     | 45MB        | 27x less |
| With .gitignore      | N/A           | N/A       | 0.15s       | N/A      |

### Performance Characteristics

- **Linear scaling:** Performance scales linearly with file count
- **I/O bound:** SSD vs HDD makes a significant difference
- **Cache friendly:** Repeated searches benefit from OS file cache
- **Memory constant:** Uses ~45MB regardless of result count

### Performance Tips

1. **Use specific patterns:** `src/**/*.py` is faster than `**/*.py`
2. **Limit depth:** Use `max_depth` when you know the structure
3. **Exclude early:** Use `exclude` patterns to skip large directories
4. **Leverage .gitignore:** Default behavior skips ignored files

## Cookbook - Real-World Examples

### Working with Git Repositories

```python
import vexy_glob

# Find all Python files, respecting .gitignore (default behavior)
for path in vexy_glob.find("**/*.py"):
    print(path)

# Include files that are gitignored
for path in vexy_glob.find("**/*.py", ignore_git=True):
    print(path)
```

### Finding Large Log Files

```python
import vexy_glob

# Find log files larger than 100MB
for path in vexy_glob.find("**/*.log", min_size=vexy_glob.parse_size("100M")):
    size_mb = os.path.getsize(path) / 1024 / 1024
    print(f"{path}: {size_mb:.1f}MB")

# Find log files between 10MB and 1GB
for path in vexy_glob.find(
    "**/*.log",
    min_size=vexy_glob.parse_size("10M"),
    max_size=vexy_glob.parse_size("1G")
):
    print(path)
```

### Finding Recently Modified Files

```python
import vexy_glob
from datetime import datetime, timedelta

# Files modified in the last 24 hours
for path in vexy_glob.find("**/*", mtime_after="-1d"):
    print(path)

# Files modified between 1 and 7 days ago
for path in vexy_glob.find(
    "**/*",
    mtime_after="-7d",
    mtime_before="-1d"
):
    print(path)

# Files modified after a specific date
for path in vexy_glob.find("**/*", mtime_after="2024-01-01"):
    print(path)
```

### Code Search - Finding TODOs and FIXMEs

```python
import vexy_glob

# Find all TODO comments in Python files
for match in vexy_glob.find("**/*.py", content=r"TODO|FIXME"):
    print(f"{match.path}:{match.line_number}: {match.line_text.strip()}")

# Find specific function definitions
for match in vexy_glob.find("**/*.py", content=r"def\s+process_data"):
    print(f"Found function at {match.path}:{match.line_number}")
```

### Finding Duplicate Files by Size

```python
import vexy_glob
from collections import defaultdict

# Group files by size to find potential duplicates
size_groups = defaultdict(list)

for path in vexy_glob.find("**/*", file_type="f"):
    size = os.path.getsize(path)
    if size > 0:  # Skip empty files
        size_groups[size].append(path)

# Print potential duplicates
for size, paths in size_groups.items():
    if len(paths) > 1:
        print(f"\nPotential duplicates ({size} bytes):")
        for path in paths:
            print(f"  {path}")
```

### Cleaning Build Artifacts

```python
import vexy_glob
import os

# Find and remove Python cache files
cache_patterns = [
    "**/__pycache__/**",
    "**/*.pyc",
    "**/*.pyo",
    "**/.pytest_cache/**",
    "**/.mypy_cache/**"
]

for pattern in cache_patterns:
    for path in vexy_glob.find(pattern, hidden=True):
        if os.path.isfile(path):
            os.remove(path)
            print(f"Removed: {path}")
        elif os.path.isdir(path):
            shutil.rmtree(path)
            print(f"Removed directory: {path}")
```

### Project Statistics

```python
import vexy_glob
from collections import Counter
import os

# Count files by extension
extension_counts = Counter()

for path in vexy_glob.find("**/*", file_type="f"):
    ext = os.path.splitext(path)[1].lower()
    if ext:
        extension_counts[ext] += 1

# Print top 10 file types
print("Top 10 file types in project:")
for ext, count in extension_counts.most_common(10):
    print(f"  {ext}: {count} files")

# Advanced statistics
total_size = 0
file_count = 0
largest_file = None
largest_size = 0

for path in vexy_glob.find("**/*", file_type="f"):
    size = os.path.getsize(path)
    total_size += size
    file_count += 1
    if size > largest_size:
        largest_size = size
        largest_file = path

print(f"\nProject Statistics:")
print(f"Total files: {file_count:,}")
print(f"Total size: {total_size / 1024 / 1024:.1f} MB")
print(f"Average file size: {total_size / file_count / 1024:.1f} KB")
print(f"Largest file: {largest_file} ({largest_size / 1024 / 1024:.1f} MB)")
```

### Integration with pandas

```python
import vexy_glob
import pandas as pd
import os

# Create a DataFrame of all Python files with metadata
file_data = []

for path in vexy_glob.find("**/*.py"):
    stat = os.stat(path)
    file_data.append({
        'path': path,
        'size': stat.st_size,
        'modified': pd.Timestamp(stat.st_mtime, unit='s'),
        'lines': sum(1 for _ in open(path, 'r', errors='ignore'))
    })

df = pd.DataFrame(file_data)

# Analyze the data
print(f"Total Python files: {len(df)}")
print(f"Total lines of code: {df['lines'].sum():,}")
print(f"Average file size: {df['size'].mean():.0f} bytes")
print(f"\nLargest files:")
print(df.nlargest(5, 'size')[['path', 'size', 'lines']])
```

### Parallel Processing Found Files

```python
import vexy_glob
from concurrent.futures import ProcessPoolExecutor
import os

def process_file(path):
    """Process a single file (e.g., count lines)"""
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return path, sum(1 for _ in f)
    except:
        return path, 0

# Process all Python files in parallel
with ProcessPoolExecutor() as executor:
    # Get all files as a list
    files = vexy_glob.find("**/*.py", as_list=True)
    
    # Process in parallel
    results = executor.map(process_file, files)
    
    # Collect results
    total_lines = 0
    for path, lines in results:
        total_lines += lines
        if lines > 1000:
            print(f"Large file: {path} ({lines} lines)")
    
    print(f"\nTotal lines of code: {total_lines:,}")
```

## Migration Guide

### Migrating from `glob`

```python
# OLD: Using glob
import glob
import os

# Find all Python files
files = glob.glob("**/*.py", recursive=True)

# Filter by size manually
large_files = []
for f in files:
    if os.path.getsize(f) > 1024 * 1024:  # 1MB
        large_files.append(f)

# NEW: Using vexy_glob
import vexy_glob

# Find large Python files directly
large_files = vexy_glob.find("**/*.py", min_size=1024*1024, as_list=True)
```

### Migrating from `pathlib`

```python
# OLD: Using pathlib
from pathlib import Path

# Find all Python files
files = list(Path(".").rglob("*.py"))

# Filter by modification time manually
import datetime
recent = []
for f in files:
    if f.stat().st_mtime > (datetime.datetime.now() - datetime.timedelta(days=7)).timestamp():
        recent.append(f)

# NEW: Using vexy_glob
import vexy_glob

# Find recent Python files directly
recent = vexy_glob.find("**/*.py", mtime_after="-7d", as_path=True, as_list=True)
```

### Migrating from `os.walk`

```python
# OLD: Using os.walk
import os

# Find all .txt files
txt_files = []
for root, dirs, files in os.walk("."):
    for file in files:
        if file.endswith(".txt"):
            txt_files.append(os.path.join(root, file))

# NEW: Using vexy_glob
import vexy_glob

# Much simpler and faster!
txt_files = vexy_glob.find("**/*.txt", as_list=True)
```

## Development

This project is built with `maturin` - a tool for building and publishing Rust-based Python extensions.

### Prerequisites

- Python 3.8 or later
- Rust toolchain (install from [rustup.rs](https://rustup.rs/))
- `uv` for fast Python package management (optional but recommended)

### Setting Up Development Environment

```bash
# Clone the repository
git clone https://github.com/vexyart/vexy-glob.git
cd vexy-glob

# Set up a virtual environment (using uv for faster installation)
pip install uv
uv venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install development dependencies
uv sync

# Build the Rust extension in development mode
python sync_version.py  # Sync version from git tags to Cargo.toml
maturin develop

# Run tests
pytest tests/

# Run benchmarks
pytest tests/test_benchmarks.py -v --benchmark-only
```

### Building Release Artifacts

The project uses a streamlined build system with automatic versioning from git tags.

#### Quick Build

```bash
# Build both wheel and source distribution
./build.sh
```

This script will:
1. Sync the version from git tags to `Cargo.toml`
2. Build an optimized wheel for your platform
3. Build a source distribution (sdist)
4. Place all artifacts in the `dist/` directory

#### Manual Build

```bash
# Ensure you have the latest tags
git fetch --tags

# Sync version to Cargo.toml
python sync_version.py

# Build wheel (platform-specific)
python -m maturin build --release -o dist/

# Build source distribution
python -m maturin sdist -o dist/
```

### Build System Details

The project uses:
- **maturin** as the build backend for creating Python wheels from Rust code
- **setuptools-scm** for automatic versioning based on git tags
- **sync_version.py** to synchronize versions between git tags and `Cargo.toml`

Key files:
- `pyproject.toml` - Python project configuration with maturin as build backend
- `Cargo.toml` - Rust project configuration
- `sync_version.py` - Version synchronization script
- `build.sh` - Convenience build script

### Versioning

Versions are managed through git tags:

```bash
# Create a new version tag
git tag v1.0.4
git push origin v1.0.4

# Build with the new version
./build.sh
```

The version will be automatically detected and used for both the Python package and Rust crate.

### Project Structure

```
vexy-glob/
├── src/                    # Rust source code
│   ├── lib.rs             # Main Rust library with PyO3 bindings
│   └── ...
├── vexy_glob/             # Python package
│   ├── __init__.py        # Python API wrapper
│   ├── __main__.py        # CLI implementation
│   └── ...
├── tests/                 # Python tests
│   ├── test_*.py          # Unit and integration tests
│   └── test_benchmarks.py # Performance benchmarks
├── Cargo.toml             # Rust project configuration
├── pyproject.toml         # Python project configuration
├── sync_version.py        # Version synchronization script
└── build.sh               # Build automation script
```

### CI/CD

The project uses GitHub Actions for continuous integration:
- Testing on Linux, macOS, and Windows
- Python versions 3.8 through 3.12
- Automatic wheel building for releases
- Cross-platform compatibility testing

## Exceptions and Error Handling

### Exception Hierarchy

```python
VexyGlobError(Exception)
├── PatternError(VexyGlobError, ValueError)
│   └── Raised for invalid glob patterns
├── SearchError(VexyGlobError, IOError)  
│   └── Raised for I/O or permission errors
└── TraversalNotSupportedError(VexyGlobError, NotImplementedError)
    └── Raised for unsupported operations
```

### Error Handling Examples

```python
import vexy_glob
from vexy_glob import VexyGlobError, PatternError, SearchError

try:
    # Invalid pattern
    for path in vexy_glob.find("[invalid"):
        print(path)
except PatternError as e:
    print(f"Invalid pattern: {e}")

try:
    # Permission denied or I/O error
    for path in vexy_glob.find("**/*", root="/root"):
        print(path)
except SearchError as e:
    print(f"Search failed: {e}")

# Handle any vexy_glob error
try:
    results = vexy_glob.find("**/*.py", content="[invalid regex")
except VexyGlobError as e:
    print(f"Operation failed: {e}")
```

## Platform-Specific Considerations

### Windows

- Use forward slashes `/` in patterns (automatically converted)
- Hidden files: Files with hidden attribute are included with `hidden=True`
- Case sensitivity: Windows is case-insensitive by default

```python
# Windows-specific examples
import vexy_glob

# These are equivalent on Windows
vexy_glob.find("C:/Users/*/Documents/*.docx")
vexy_glob.find("C:\\Users\\*\\Documents\\*.docx")  # Also works

# Find hidden files on Windows
for path in vexy_glob.find("**/*", hidden=True):
    print(path)
```

### macOS

- `.DS_Store` files are excluded by default (via .gitignore)
- Case sensitivity depends on file system (usually case-insensitive)

```python
# macOS-specific examples
import vexy_glob

# Exclude .DS_Store and other macOS metadata
for path in vexy_glob.find("**/*", exclude=["**/.DS_Store", "**/.Spotlight-V100", "**/.Trashes"]):
    print(path)
```

### Linux

- Always case-sensitive
- Hidden files start with `.`
- Respects standard Unix permissions

```python
# Linux-specific examples
import vexy_glob

# Find files in home directory config
for path in vexy_glob.find("~/.config/**/*.conf", hidden=True):
    print(path)
```

## Troubleshooting

### Common Issues

#### 1. No results found

```python
# Check if you need hidden files
results = list(vexy_glob.find("*"))
if not results:
    # Try with hidden files
    results = list(vexy_glob.find("*", hidden=True))

# Check if .gitignore is excluding files
results = list(vexy_glob.find("**/*.py", ignore_git=True))
```

#### 2. Pattern not matching expected files

```python
# Debug pattern matching
import vexy_glob

# Too specific?
print(list(vexy_glob.find("src/lib/test.py")))  # Only exact match

# Use wildcards
print(list(vexy_glob.find("src/**/test.py")))   # Any depth
print(list(vexy_glob.find("src/*/test.py")))    # One level only
```

#### 3. Content search not finding matches

```python
# Check regex syntax
import vexy_glob

# Wrong: Python regex syntax
results = vexy_glob.find("**/*.py", content=r"import\s+{re,os}")

# Correct: Standard regex
results = vexy_glob.find("**/*.py", content=r"import\s+(re|os)")

# Case sensitivity
results = vexy_glob.find("**/*.py", content="TODO", case_sensitive=False)
```

#### 4. Performance issues

```python
# Optimize your search
import vexy_glob

# Slow: Searching everything
for path in vexy_glob.find("**/*.py", content="import"):
    print(path)

# Fast: Limit scope
for path in vexy_glob.find("src/**/*.py", content="import", max_depth=3):
    print(path)

# Use exclusions
for path in vexy_glob.find(
    "**/*.py",
    exclude=["**/node_modules/**", "**/.venv/**", "**/build/**"]
):
    print(path)
```

### Build Issues

If you encounter build issues:

1. **Rust not found**: Install Rust from [rustup.rs](https://rustup.rs/)
2. **maturin not found**: Run `pip install maturin`
3. **Version mismatch**: Run `python sync_version.py` to sync versions
4. **Import errors**: Ensure you've run `maturin develop` after changes
5. **Build fails**: Check that you have the latest Rust stable toolchain

### Debug Mode

```python
import vexy_glob
import logging

# Enable debug logging
logging.basicConfig(level=logging.DEBUG)

# This will show internal operations
for path in vexy_glob.find("**/*.py"):
    print(path)
```

## FAQ

**Q: Why is vexy_glob so much faster than glob?**

A: vexy_glob uses Rust's parallel directory traversal, releases Python's GIL, and streams results as they're found instead of collecting everything first.

**Q: Does vexy_glob follow symbolic links?**

A: By default, no. Use `follow_symlinks=True` to enable. Loop detection is built-in.

**Q: Can I use vexy_glob with async/await?**

A: Yes! Use it with asyncio.to_thread():
```python
import asyncio
import vexy_glob

async def find_files():
    return await asyncio.to_thread(
        vexy_glob.find, "**/*.py", as_list=True
    )
```

**Q: How do I search in multiple directories?**

A: Call find() multiple times or use a common parent:
```python
# Option 1: Multiple calls
results = []
for root in ["src", "tests", "docs"]:
    results.extend(vexy_glob.find("**/*.py", root=root, as_list=True))

# Option 2: Common parent with specific patterns
results = vexy_glob.find("{src,tests,docs}/**/*.py", as_list=True)
```

**Q: Is the content search as powerful as ripgrep?**

A: Yes! It uses the same grep-searcher crate that powers ripgrep, including SIMD optimizations.

### Advanced Configuration

#### Custom Ignore Files

```python
import vexy_glob

# By default, respects .gitignore
for path in vexy_glob.find("**/*.py"):
    print(path)

# Also respects .ignore and .fdignore files
# Create .ignore in your project root:
# echo "test_*.py" > .ignore

# Now test files will be excluded
for path in vexy_glob.find("**/*.py"):
    print(path)  # test_*.py files excluded
```

#### Thread Configuration

```python
import vexy_glob
import os

# Auto-detect (default)
for path in vexy_glob.find("**/*.py"):
    pass

# Limit threads for CPU-bound operations
for match in vexy_glob.find("**/*.py", content="TODO", threads=2):
    pass

# Max parallelism for I/O-bound operations
cpu_count = os.cpu_count() or 4
for path in vexy_glob.find("**/*", threads=cpu_count * 2):
    pass
```

### Contributing

We welcome contributions! Here's how to get started:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature-name`)
3. Make your changes
4. Run tests (`pytest tests/`)
5. Format code (`cargo fmt` for Rust, `ruff format` for Python)
6. Commit with descriptive messages
7. Push and open a pull request

Before submitting:
- Ensure all tests pass
- Add tests for new functionality
- Update documentation as needed
- Follow existing code style

#### Running the Full Test Suite

```bash
# Python tests
pytest tests/ -v

# Python tests with coverage
pytest tests/ --cov=vexy_glob --cov-report=html

# Rust tests
cargo test

# Benchmarks
pytest tests/test_benchmarks.py -v --benchmark-only

# Linting
cargo clippy -- -D warnings
ruff check .
```

## API Stability and Versioning

vexy_glob follows [Semantic Versioning](https://semver.org/):

- **Major version (1.x.x)**: Breaking API changes
- **Minor version (x.1.x)**: New features, backwards compatible
- **Patch version (x.x.1)**: Bug fixes only

### Stable API Guarantees

The following are guaranteed stable in 1.x:

- `find()` function signature and basic parameters
- `glob()` and `iglob()` compatibility functions
- `SearchResult` object attributes
- Exception hierarchy
- CLI command structure

### Experimental Features

Features marked experimental may change:

- Thread count optimization algorithms
- Internal buffer size tuning
- Specific error message text

## Performance Tuning Guide

### For Maximum Speed

```python
import vexy_glob

# 1. Be specific with patterns
# Slow:
vexy_glob.find("**/*.py")
# Fast:
vexy_glob.find("src/**/*.py")

# 2. Use depth limits when possible
vexy_glob.find("**/*.py", max_depth=3)

# 3. Exclude unnecessary directories
vexy_glob.find(
    "**/*.py",
    exclude=["**/venv/**", "**/node_modules/**", "**/.git/**"]
)

# 4. Use file type filters
vexy_glob.find("**/*.py", file_type="f")  # Skip directories
```

### For Memory Efficiency

```python
# Stream results instead of collecting
# Memory efficient:
for path in vexy_glob.find("**/*"):
    process(path)  # Process one at a time

# Memory intensive:
all_files = vexy_glob.find("**/*", as_list=True)  # Loads all in memory
```

### For I/O Optimization

```python
# Optimize thread count based on storage type
import vexy_glob

# SSD: More threads help
for path in vexy_glob.find("**/*", threads=8):
    pass

# HDD: Fewer threads to avoid seek thrashing
for path in vexy_glob.find("**/*", threads=2):
    pass

# Network storage: Single thread might be best
for path in vexy_glob.find("**/*", threads=1):
    pass
```

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built on the excellent Rust crates:
  - [`ignore`](https://github.com/BurntSushi/ripgrep/tree/master/crates/ignore) - Fast directory traversal
  - [`grep-searcher`](https://github.com/BurntSushi/ripgrep/tree/master/crates/grep-searcher) - High-performance text search
  - [`globset`](https://github.com/BurntSushi/ripgrep/tree/master/crates/globset) - Efficient glob matching
- Inspired by tools like [`fd`](https://github.com/sharkdp/fd) and [`ripgrep`](https://github.com/BurntSushi/ripgrep)
- Thanks to the PyO3 team for excellent Python-Rust bindings

## Related Projects

- [`fd`](https://github.com/sharkdp/fd) - A simple, fast alternative to `find`
- [`ripgrep`](https://github.com/BurntSushi/ripgrep) - Recursively search directories for a regex pattern
- [`walkdir`](https://github.com/python/cpython/blob/main/Lib/os.py) - Python's built-in directory traversal
- [`scandir`](https://github.com/benhoyt/scandir) - Better directory iteration for Python

---

**Happy fast file finding!** 🚀

If you find `vexy_glob` useful, please consider giving it a star on [GitHub](https://github.com/vexyart/vexy-glob)!

</document_content>
</document>

<document index="17">
<source>TODO.md</source>
<document_content>
# TODO.md - vexy_glob Implementation Tasks

## 🚀 CURRENT PRIORITIES

### Priority 1: Performance Optimizations
- [ ] Add same_file_system option to prevent crossing mount points
- [ ] Add result sorting options (name, size, mtime)
- [ ] Implement smart-case matching optimization
- [ ] Add literal string optimization paths
- [ ] Configure optimal buffer sizes for different workloads
- [ ] Optimize hot paths based on profiling

### Priority 2: Platform Testing
- [ ] Test and fix Windows-specific path handling
- [ ] Verify Linux compatibility across distributions
- [ ] Test macOS-specific features (e.g., .DS_Store handling)
- [ ] Handle platform-specific file system features
- [ ] Test performance across different platforms
- [ ] Verify Unicode path handling on all platforms
- [ ] Test with real-world codebases
- [ ] Benchmark against fd and ripgrep directly
- [ ] Test with extremely large directories (1M+ files)
- [ ] Verify memory usage stays constant
- [ ] Test interruption and cleanup behavior

### Priority 3: Release Preparation
- [ ] Run full test suite on all platforms via CI
- [ ] Manual testing on Windows, Linux, macOS
- [ ] Test installation from wheels on clean systems
- [ ] Verify all examples work correctly
- [ ] Performance regression testing
- [ ] Update version to 1.0.0
- [ ] Create comprehensive release notes
- [ ] Build wheels for all platforms
- [ ] Publish to Test PyPI
- [ ] Test installation from Test PyPI
- [ ] Publish to PyPI
- [ ] Create GitHub release with artifacts
- [ ] Announce on Python forums and social media

## Notes

- Build system has been modernized to use maturin directly instead of hatch
- Version management now uses git tags with setuptools-scm
- Current version: 1.0.3

</document_content>
</document>

<document index="18">
<source>WORK.md</source>
<document_content>
# WORK.md - Current Work Progress

## 🔄 Current Phase: Performance Optimizations

### Active Tasks

1. **Performance Enhancements**
   - Add same_file_system option to prevent crossing mount points
   - Implement result sorting options (name, size, mtime)
   - Add smart-case matching optimization
   - Configure optimal buffer sizes for different workloads
   - Profile and optimize hot paths

## Project Status

**PRODUCTION READY** - All core functionality is complete:
- ✅ File Finding: 1.8x faster than stdlib
- ✅ Content Search: Ripgrep-style functionality 
- ✅ Streaming: 10x faster time to first result
- ✅ Full Test Coverage: 99+ tests, 97% coverage
- ✅ CLI: Complete command-line interface
- ✅ Build System: Modernized with maturin
- ✅ CI/CD: Multi-platform automated builds

## Recent Completions

### Issue #102 - Comprehensive Documentation ✅
- Expanded README.md from 419 to 1464 lines (3.5x increase)
- Added complete API reference, cookbook, and migration guides
- Created platform-specific documentation and troubleshooting sections

### Build System Modernization ✅  
- Switched from hatch to maturin as build backend
- Configured git-tag-based versioning with setuptools-scm
- Created sync_version.py for Cargo.toml synchronization
- Updated CI/CD workflows
</document_content>
</document>

<document index="19">
<source>build.sh</source>
<document_content>
#!/bin/bash
# this_file: build.sh
# Build script for vexy_glob

set -e

echo "🔧 Syncing version..."
python sync_version.py

echo "📦 Building wheel..."
python -m maturin build --release -o dist/

echo "📦 Building source distribution..."
python -m maturin sdist -o dist/

echo "✅ Build complete!"
ls -la dist/
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/examples/compare_stdlib.py
# Language: python

import time
import glob
import tempfile
import vexy_glob
from pathlib import Path
import statistics
import os

def create_test_structure((base_dir: Path, num_files: int = 1000, num_dirs: int = 50)):
    """Create a test directory structure with many files."""

def benchmark_function((func, *args, **kwargs)):
    """Benchmark a function and return timing stats."""

def stdlib_find_py_files((root)):
    """Find Python files using stdlib glob."""

def vexy_glob_find_py_files((root)):
    """Find Python files using vexy_glob."""

def stdlib_find_all_files((root)):
    """Find all files using stdlib glob."""

def vexy_glob_find_all_files((root)):
    """Find all files using vexy_glob."""

def run_benchmarks(()):
    """Run all benchmarks."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/examples/demo.py
# Language: python

import vexy_glob
from pathlib import Path
import time
import glob

def demo_basic_usage(()):
    """Demonstrate basic vexy_glob usage."""

def demo_streaming(()):
    """Demonstrate streaming capabilities."""

def demo_filters(()):
    """Demonstrate filtering capabilities."""

def demo_performance(()):
    """Demonstrate performance compared to stdlib."""

def main(()):
    """Run all demos."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/examples/pafrbench.py
# Language: python

import time
import fire
import glob
import pathlib
import os
import sys
import vexy_glob

class VexyGlobBench:
    """ A Fire CLI tool to benchmark file searching methods...."""
    def _run_benchmark((self, name, func, print_paths=False)):
    def run((self, dir: str = ".", ext: str = "md", print_paths: bool = False)):
        """ Recursively finds all files with a given extension in a directory and benchmarks the time...."""

def _run_benchmark((self, name, func, print_paths=False)):

def run((self, dir: str = ".", ext: str = "md", print_paths: bool = False)):
    """ Recursively finds all files with a given extension in a directory and benchmarks the time...."""

def vexy_glob_search(()):

def glob_search(()):

def pathlib_search(()):


<document index="20">
<source>publish.sh</source>
<document_content>
#!/usr/bin/env bash
llms . "*.txt"
uvx hatch clean
gitnextver .
uvx hatch build
uvx hatch publish

</document_content>
</document>

<document index="21">
<source>pyproject.toml</source>
<document_content>
[project]
name = "vexy-glob"
dynamic = ["version"]
description = "Vexy Glob fast file finding"
readme = "README.md"
requires-python = ">=3.8"
license = { text = "MIT" }
authors = [
  { name = "Adam Twardoch", email = "adam+github@twardoch.com" },
]
keywords = ["filesystem", "find", "glob", "parallel", "rust", "search"]
classifiers = [
  "Development Status :: 3 - Alpha",
  "Intended Audience :: Developers",
  "License :: OSI Approved :: MIT License",
  "Operating System :: OS Independent",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3.8",
  "Programming Language :: Python :: 3.9",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Rust",
  "Topic :: Software Development :: Libraries",
  "Topic :: System :: Filesystems",
]
dependencies = [
  "fire>=0.7.0",
  "rich>=14.1.0",
]

[project.urls]
"Bug Tracker" = "https://github.com/vexyart/vexy-glob/issues"
"Homepage" = "https://github.com/vexyart/vexy-glob"
"Repository" = "https://github.com/vexyart/vexy-glob"

[project.scripts]
vg = "vexy_glob.__main__:main"

[build-system]
requires = ["maturin>=1.9.2", "setuptools-scm>=8.0"]
build-backend = "maturin"

[tool.cibuildwheel]
build = ["cp38-*", "cp39-*", "cp310-*", "cp311-*", "cp312-*"]
skip = ["*-musllinux_i686", "*-win32", "pp*"]
test-requires = "pytest"
test-command = "pytest {project}/tests -v"

[tool.cibuildwheel.linux]
manylinux-x86_64-image = "manylinux2014"
manylinux-i686-image = "manylinux2014"

[tool.cibuildwheel.macos]
archs = ["x86_64", "arm64", "universal2"]

[tool.cibuildwheel.windows]
archs = ["AMD64"]

[tool.setuptools_scm]
version_file = "_version.py"
version_scheme = "no-guess-dev"
local_scheme = "no-local-version"

[tool.hatch.envs.default]
dependencies = [
  "pytest>=8.3.5",
  "loguru>=0.7.3",
  "maturin>=1.9.2",
  "ruff>=0.1.0",
]

[tool.hatch.envs.default.scripts]
build = "maturin develop"
build-release = "maturin develop --release"
test = "pytest tests/ -v"
lint = "ruff check src/ vexy_glob/ tests/"
format = "ruff format src/ vexy_glob/ tests/"
check = "ruff check src/ vexy_glob/ tests/ && pytest tests/ -v"

[tool.hatch.envs.test]
template = "default"
matrix = [{ python = ["3.8", "3.9", "3.10", "3.11", "3.12"] }]

[tool.maturin]
features = ["pyo3/extension-module"]
module-name = "vexy_glob._vexy_glob"
python-source = "."
strip = true

[tool.pytest.ini_options]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.ruff]
target-version = "py38"
line-length = 100

[tool.ruff.lint]
select = ["E", "F", "W", "I"]
ignore = ["E501"]  # Line too long (handled by formatter)


</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/src/lib.rs
# Language: rust

struct SearchResultRust {
}

struct VexyGlobIterator {
}

struct SearchSink {
}


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/sync_version.py
# Language: python

import re
import subprocess
import sys
from pathlib import Path

def get_git_version(()) -> str:
    """Get version from git tags using hatch-vcs logic."""

def update_cargo_toml((version: str)) -> None:
    """Update version in Cargo.toml."""

def main(()):
    """Main entry point."""


<document index="22">
<source>test_gitignore/.gitignore</source>
<document_content>
*.log

</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_atime_filtering.py
# Language: python

import os
import tempfile
import time
import pytest
from pathlib import Path
from datetime import datetime, timezone
import vexy_glob

def test_atime_after_filtering(()):
    """Test filtering files accessed after a specific time."""

def test_atime_before_filtering(()):
    """Test filtering files accessed before a specific time."""

def test_atime_range_filtering(()):
    """Test filtering files within an access time range."""

def test_atime_with_relative_time(()):
    """Test access time filtering with relative time formats."""

def test_atime_with_datetime_objects(()):
    """Test access time filtering with datetime objects."""

def test_atime_with_content_search(()):
    """Test access time filtering combined with content search."""

def test_atime_with_size_filtering(()):
    """Test access time filtering combined with size filtering."""

def test_atime_with_exclude_patterns(()):
    """Test access time filtering combined with exclude patterns."""

def test_atime_iso_date_format(()):
    """Test access time filtering with ISO date formats."""

def test_atime_no_match(()):
    """Test access time filtering that matches no files."""

def test_atime_edge_cases(()):
    """Test edge cases for access time filtering."""

def test_atime_with_mtime_filtering(()):
    """Test access time filtering combined with modification time filtering."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_basic.py
# Language: python

import vexy_glob
import pytest
from pathlib import Path
import tempfile
import os
import subprocess

class TestWithTempDir:
    """Tests that create temporary directory structures."""
    def test_find_all_files((self, temp_dir)):
        """Test finding all files in temp directory."""
    def test_hidden_files_excluded_by_default((self, temp_dir)):
        """Test that hidden files are excluded by default."""
    def test_gitignore_respected_by_default((self, temp_dir)):
        """Test that .gitignore is respected by default."""
    def test_recursive_glob((self, temp_dir)):
        """Test recursive glob pattern."""
    def test_streaming_results((self, temp_dir)):
        """Test that results stream immediately."""

def test_import(()):
    """Test that the module can be imported."""

def test_find_in_current_directory(()):
    """Test finding files in current directory."""

def test_find_returns_strings_by_default(()):
    """Test that find returns strings by default."""

def test_find_with_path_objects(()):
    """Test that find can return Path objects."""

def test_glob_compatibility(()):
    """Test glob function works like stdlib glob."""

def test_iglob_returns_iterator(()):
    """Test iglob returns an iterator."""

def test_pattern_error(()):
    """Test that invalid patterns raise PatternError."""

def test_find_with_file_type(()):
    """Test filtering by file type."""

def test_max_depth(()):
    """Test max_depth parameter."""

def test_extension_filter(()):
    """Test filtering by extension."""

def temp_dir((self)):
    """Create a temporary directory with test files."""

def test_find_all_files((self, temp_dir)):
    """Test finding all files in temp directory."""

def test_hidden_files_excluded_by_default((self, temp_dir)):
    """Test that hidden files are excluded by default."""

def test_gitignore_respected_by_default((self, temp_dir)):
    """Test that .gitignore is respected by default."""

def test_recursive_glob((self, temp_dir)):
    """Test recursive glob pattern."""

def test_streaming_results((self, temp_dir)):
    """Test that results stream immediately."""

def test_content_search_find_function(()):
    """Test content search using find() function."""

def test_content_search_dedicated_function(()):
    """Test content search using dedicated search() function."""

def test_content_search_with_path_objects(()):
    """Test content search returning Path objects."""

def test_content_search_no_matches(()):
    """Test content search with pattern that matches no content."""

def test_content_search_as_list(()):
    """Test content search with as_list=True."""

def temp_dir_with_content(()):
    """Create a temporary directory with files containing searchable content."""

def test_content_search_in_temp_dir((temp_dir_with_content)):
    """Test content search in a controlled temporary directory."""

def test_content_search_regex_patterns((temp_dir_with_content)):
    """Test content search with regex patterns."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_cli.py
# Language: python

import sys
import tempfile
import subprocess
import json
from pathlib import Path
import pytest
from io import StringIO
from unittest.mock import patch, Mock
from vexy_glob.__main__ import Cli, main
from vexy_glob.__main__ import main

class TestVexyGlobCLISizeParser:
    """Test human-readable size parsing."""
    def test_parse_size_basic((self)):
        """Test basic size parsing."""
    def test_parse_size_with_decimals((self)):
        """Test size parsing with decimal numbers."""
    def test_parse_size_with_b_suffix((self)):
        """Test size parsing with 'b' suffix."""
    def test_parse_size_empty((self)):
        """Test parsing empty size string."""
    def test_parse_size_invalid((self)):
        """Test parsing invalid size strings."""

class TestVexyGlobCLIFormatting:
    """Test output formatting for search results."""
    def test_format_basic_output((self)):
        """Test basic output formatting."""

class TestVexyGlobCLIFindCommand:
    """Test the 'find' command functionality."""
    def setup_method((self)):
        """Set up test fixtures."""
    def test_find_basic_pattern((self)):
        """Test basic pattern matching."""
    def test_find_with_size_filter((self)):
        """Test find with size filtering."""
    def test_find_with_type_filter((self)):
        """Test find with file type filtering."""
    def test_find_error_handling((self)):
        """Test error handling in find command."""

class TestVexyGlobCLISearchCommand:
    """Test the 'search' command functionality."""
    def setup_method((self)):
        """Set up test fixtures."""
    def test_search_basic_pattern((self)):
        """Test basic content search."""
    def test_search_regex_pattern((self)):
        """Test regex pattern search."""
    def test_search_no_color((self)):
        """Test search with no color output."""
    def test_search_error_handling((self)):
        """Test error handling in search command."""

class TestVexyGlobCLIIntegration:
    """Test CLI integration and subprocess calls."""
    def setup_method((self)):
        """Set up test fixtures."""
    def test_cli_find_via_subprocess((self)):
        """Test CLI find command via subprocess."""
    def test_cli_search_via_subprocess((self)):
        """Test CLI search command via subprocess."""
    def test_cli_find_with_size_filter_subprocess((self)):
        """Test CLI find with size filter via subprocess."""
    def test_cli_invalid_arguments((self)):
        """Test CLI with invalid arguments."""
    def test_cli_help_output((self)):
        """Test CLI help output."""

class TestVexyGlobCLIPipelineCompatibility:
    """Test CLI compatibility with Unix pipelines."""
    def setup_method((self)):
        """Set up test fixtures."""
    def test_pipeline_with_head((self)):
        """Test CLI output piped to head command."""
    def test_pipeline_with_grep((self)):
        """Test CLI output piped to grep command."""
    def test_pipeline_with_wc((self)):
        """Test CLI output piped to wc command."""
    def test_search_pipeline_with_cut((self)):
        """Test search output piped to cut command."""

class TestVexyGlobCLIErrorHandling:
    """Test CLI error handling and edge cases."""
    def test_broken_pipe_handling((self)):
        """Test that broken pipe is handled gracefully."""
    def test_keyboard_interrupt_handling((self)):
        """Test keyboard interrupt handling."""
    def test_invalid_size_format_error((self)):
        """Test error handling for invalid size format."""

class TestVexyGlobCLIFireIntegration:
    """Test fire library integration."""
    def test_main_function_exists((self)):
        """Test that main function exists and is callable."""
    def test_cli_class_methods((self)):
        """Test that CLI class has required methods."""
    def test_cli_class_instantiation((self)):
        """Test CLI class can be instantiated."""

def test_parse_size_basic((self)):
    """Test basic size parsing."""

def test_parse_size_with_decimals((self)):
    """Test size parsing with decimal numbers."""

def test_parse_size_with_b_suffix((self)):
    """Test size parsing with 'b' suffix."""

def test_parse_size_empty((self)):
    """Test parsing empty size string."""

def test_parse_size_invalid((self)):
    """Test parsing invalid size strings."""

def test_format_basic_output((self)):
    """Test basic output formatting."""

def setup_method((self)):
    """Set up test fixtures."""

def test_find_basic_pattern((self)):
    """Test basic pattern matching."""

def test_find_with_size_filter((self)):
    """Test find with size filtering."""

def test_find_with_type_filter((self)):
    """Test find with file type filtering."""

def test_find_error_handling((self)):
    """Test error handling in find command."""

def setup_method((self)):
    """Set up test fixtures."""

def test_search_basic_pattern((self)):
    """Test basic content search."""

def test_search_regex_pattern((self)):
    """Test regex pattern search."""

def test_search_no_color((self)):
    """Test search with no color output."""

def test_search_error_handling((self)):
    """Test error handling in search command."""

def setup_method((self)):
    """Set up test fixtures."""

def test_cli_find_via_subprocess((self)):
    """Test CLI find command via subprocess."""

def test_cli_search_via_subprocess((self)):
    """Test CLI search command via subprocess."""

def test_cli_find_with_size_filter_subprocess((self)):
    """Test CLI find with size filter via subprocess."""

def test_cli_invalid_arguments((self)):
    """Test CLI with invalid arguments."""

def test_cli_help_output((self)):
    """Test CLI help output."""

def setup_method((self)):
    """Set up test fixtures."""

def test_pipeline_with_head((self)):
    """Test CLI output piped to head command."""

def test_pipeline_with_grep((self)):
    """Test CLI output piped to grep command."""

def test_pipeline_with_wc((self)):
    """Test CLI output piped to wc command."""

def test_search_pipeline_with_cut((self)):
    """Test search output piped to cut command."""

def test_broken_pipe_handling((self)):
    """Test that broken pipe is handled gracefully."""

def test_keyboard_interrupt_handling((self)):
    """Test keyboard interrupt handling."""

def test_invalid_size_format_error((self)):
    """Test error handling for invalid size format."""

def test_main_function_exists((self)):
    """Test that main function exists and is callable."""

def test_cli_class_methods((self)):
    """Test that CLI class has required methods."""

def test_cli_class_instantiation((self)):
    """Test CLI class can be instantiated."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_ctime_filtering.py
# Language: python

import os
import tempfile
import time
import pytest
from pathlib import Path
from datetime import datetime, timezone
import vexy_glob

def test_ctime_after_filtering(()):
    """Test filtering files created after a specific time."""

def test_ctime_before_filtering(()):
    """Test filtering files created before a specific time."""

def test_ctime_range_filtering(()):
    """Test filtering files within a creation time range."""

def test_ctime_with_relative_time(()):
    """Test creation time filtering with relative time formats."""

def test_ctime_with_datetime_objects(()):
    """Test creation time filtering with datetime objects."""

def test_ctime_with_content_search(()):
    """Test creation time filtering combined with content search."""

def test_ctime_with_size_filtering(()):
    """Test creation time filtering combined with size filtering."""

def test_ctime_with_exclude_patterns(()):
    """Test creation time filtering combined with exclude patterns."""

def test_ctime_iso_date_format(()):
    """Test creation time filtering with ISO date formats."""

def test_ctime_no_match(()):
    """Test creation time filtering that matches no files."""

def test_ctime_edge_cases(()):
    """Test edge cases for creation time filtering."""

def test_ctime_with_all_time_filters(()):
    """Test creation time filtering combined with modification and access time filtering."""

def test_ctime_platform_compatibility(()):
    """Test creation time filtering works across platforms."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_custom_ignore.py
# Language: python

import os
import subprocess
import tempfile
import pytest
from pathlib import Path
import vexy_glob

def test_custom_ignore_file(()):
    """Test custom ignore file functionality."""

def test_multiple_custom_ignore_files(()):
    """Test multiple custom ignore files."""

def test_fdignore_file_auto_detection(()):
    """Test automatic detection of .fdignore files."""

def test_fdignore_disabled_with_ignore_git(()):
    """Test that .fdignore files are ignored when ignore_git=True."""

def test_custom_ignore_with_string_parameter(()):
    """Test custom ignore file with string parameter (not list)."""

def test_nonexistent_custom_ignore_file(()):
    """Test behavior with non-existent custom ignore files."""

def test_custom_ignore_with_subdirectories(()):
    """Test custom ignore files with subdirectories."""

def test_custom_ignore_with_content_search(()):
    """Test custom ignore files combined with content search."""

def test_custom_ignore_complex_patterns(()):
    """Test custom ignore files with complex patterns."""

def test_custom_ignore_with_other_filters(()):
    """Test custom ignore files combined with other filtering options."""

def test_custom_ignore_precedence(()):
    """Test precedence of custom ignore vs other ignore files."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_exclude_patterns.py
# Language: python

import os
import tempfile
import pytest
from pathlib import Path
import vexy_glob

def test_single_exclude_pattern(()):
    """Test excluding files with a single pattern."""

def test_multiple_exclude_patterns(()):
    """Test excluding files with multiple patterns."""

def test_exclude_with_directories(()):
    """Test excluding directories and their contents."""

def test_exclude_with_glob_pattern(()):
    """Test exclude patterns work with glob patterns in find."""

def test_exclude_with_content_search(()):
    """Test exclude patterns work with content search."""

def test_exclude_case_sensitivity(()):
    """Test exclude pattern case sensitivity."""

def test_exclude_hidden_files(()):
    """Test exclude patterns with hidden files."""

def test_exclude_with_size_filtering(()):
    """Test exclude patterns combined with size filtering."""

def test_exclude_empty_list(()):
    """Test that empty exclude list doesn't filter anything."""

def test_exclude_pattern_priority(()):
    """Test that exclude patterns take priority over include patterns."""

def test_complex_exclude_patterns(()):
    """Test complex exclude pattern scenarios."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_size_filtering.py
# Language: python

import os
import tempfile
from pathlib import Path
import pytest
import vexy_glob

def create_test_files_with_sizes((base_dir)):
    """Create test files with specific sizes."""

def test_min_size_filtering(()):
    """Test filtering files by minimum size."""

def test_max_size_filtering(()):
    """Test filtering files by maximum size."""

def test_size_range_filtering(()):
    """Test filtering files by size range."""

def test_size_filtering_with_directories(()):
    """Test that size filtering only applies to files, not directories."""

def test_size_filtering_with_content_search(()):
    """Test that size filtering works with content search."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_symlinks.py
# Language: python

import os
import tempfile
import pytest
from pathlib import Path
import vexy_glob

def test_symlink_following_disabled_by_default(()):
    """Test that symlinks are not followed by default."""

def test_symlink_following_enabled(()):
    """Test that symlinks are followed when follow_symlinks=True."""

def test_symlink_loop_detection(()):
    """Test that symlink loops are detected and handled gracefully."""

def test_symlink_depth_behavior(()):
    """Test symlink behavior with max_depth restrictions."""

def test_symlink_with_content_search(()):
    """Test symlink following with content search."""

def test_symlink_with_file_type_filtering(()):
    """Test symlink following with file type filtering."""

def test_symlink_with_filters(()):
    """Test symlink following combined with other filters."""

def test_broken_symlink_handling(()):
    """Test handling of broken symlinks."""

def test_symlink_complex_scenario(()):
    """Test a complex symlink scenario with nested structures."""

def test_symlink_parameter_validation(()):
    """Test that symlink parameter is properly validated."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_time_filtering.py
# Language: python

import os
import time
import tempfile
from pathlib import Path
from datetime import datetime, timedelta
import pytest
import vexy_glob

def create_test_files_with_times((base_dir)):
    """Create test files with specific modification times."""

def test_mtime_after_filtering(()):
    """Test filtering files modified after a specific time."""

def test_mtime_before_filtering(()):
    """Test filtering files modified before a specific time."""

def test_mtime_range_filtering(()):
    """Test filtering files modified within a time range."""

def test_mtime_with_directories(()):
    """Test that modification time filtering applies to directories."""

def test_mtime_with_content_search(()):
    """Test that time filtering works with content search."""

def test_mtime_with_size_filtering(()):
    """Test combining time and size filtering."""

def test_mtime_with_zero_timestamp(()):
    """Test handling of zero/negative timestamps."""

def test_datetime_to_timestamp_conversion(()):
    """Test that datetime objects work (via float conversion)."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/tests/test_time_formats.py
# Language: python

import os
import time
import tempfile
from pathlib import Path
from datetime import datetime, timedelta, timezone
import pytest
import vexy_glob

def test_relative_time_formats(()):
    """Test relative time format support (-1d, -2h, etc)."""

def test_iso_date_formats(()):
    """Test ISO date format support."""

def test_datetime_object_support(()):
    """Test that datetime objects are handled correctly."""

def test_mixed_time_formats(()):
    """Test mixing different time format types."""

def test_invalid_time_formats(()):
    """Test that invalid time formats raise appropriate errors."""

def test_timezone_handling(()):
    """Test that timezone-aware dates work correctly."""

def test_relative_seconds_and_days(()):
    """Test edge cases for relative time units."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/vexy_glob/__init__.py
# Language: python

import os
from pathlib import Path
from typing import Union, List, Iterator, Optional, Literal, TYPE_CHECKING
from datetime import datetime, timezone
import time
from . import _vexy_glob
from typing import TypedDict

class SearchResult(T, y, p, e, d, D, i, c, t):
    """Result from content search."""

class VexyGlobError(E, x, c, e, p, t, i, o, n):
    """Base exception for all vexy_glob errors."""

class PatternError(V, e, x, y, G, l, o, b, E, r, r, o, r, ,,  , V, a, l, u, e, E, r, r, o, r):
    """Raised when a provided glob or regex pattern is invalid."""
    def __init__((self, message: str, pattern: str)):

class SearchError(V, e, x, y, G, l, o, b, E, r, r, o, r, ,,  , I, O, E, r, r, o, r):
    """Raised for non-recoverable I/O or traversal errors."""

class TraversalNotSupportedError(V, e, x, y, G, l, o, b, E, r, r, o, r, ,,  , N, o, t, I, m, p, l, e, m, e, n, t, e, d, E, r, r, o, r):
    """Raised when an unsupported traversal strategy is requested."""

def __init__((self, message: str, pattern: str)):

def _parse_time_param((value: Union[float, int, str, datetime, None])) -> Optional[float]:
    """ Convert various time formats to Unix timestamp...."""

def find((
    pattern: str = "*",
    root: Union[str, Path] = ".",
    *,
    content: Optional[str] = None,
    file_type: Optional[str] = None,
    extension: Optional[Union[str, List[str]]] = None,
    exclude: Optional[Union[str, List[str]]] = None,
    max_depth: Optional[int] = None,
    min_depth: int = 0,
    min_size: Optional[int] = None,
    max_size: Optional[int] = None,
    mtime_after: Optional[Union[float, int, str, datetime]] = None,
    mtime_before: Optional[Union[float, int, str, datetime]] = None,
    atime_after: Optional[Union[float, int, str, datetime]] = None,
    atime_before: Optional[Union[float, int, str, datetime]] = None,
    ctime_after: Optional[Union[float, int, str, datetime]] = None,
    ctime_before: Optional[Union[float, int, str, datetime]] = None,
    hidden: bool = False,
    ignore_git: bool = False,
    custom_ignore_files: Optional[Union[str, List[str]]] = None,
    case_sensitive: Optional[bool] = None,  # None = smart case
    follow_symlinks: bool = False,
    threads: Optional[int] = None,
    as_path: bool = False,
    as_list: bool = False,
)) -> Union[Iterator[Union[str, Path]], List[Union[str, Path]]]:
    """ Find files and directories with high performance...."""

def glob((
    pattern: str,
    *,
    recursive: bool = False,
    root_dir: Optional[Union[str, Path]] = None,
    include_hidden: bool = False,
)) -> List[str]:
    """ Drop-in replacement for glob.glob() with massive performance improvements...."""

def iglob((
    pattern: str,
    *,
    recursive: bool = False,
    root_dir: Optional[Union[str, Path]] = None,
    include_hidden: bool = False,
)) -> Iterator[str]:
    """ Drop-in replacement for glob.iglob() with streaming results...."""

def search((
    content_regex: str,
    pattern: str = "*",
    root: Union[str, Path] = ".",
    **kwargs,
)) -> Union[Iterator["SearchResult"], List["SearchResult"]]:
    """ Search for content within files, similar to ripgrep...."""


# File: /Users/adam/Developer/vcs/github.vexyart/vexy-glob/vexy_glob/__main__.py
# Language: python

import sys
import re
from pathlib import Path
from typing import Optional, Union, List
import fire
from rich.console import Console
from rich.text import Text
from rich import print as rprint
import vexy_glob

class Cli:
    """vexy_glob - Path Accelerated Finding in Rust"""
    def __init__((self)):
    def _parse_size((self, size_str: str)) -> int:
        """Parse human-readable size strings like '10k', '1M', '500G'."""
    def find((
        self,
        pattern: str = "*",
        root: str = ".",
        min_size: Optional[str] = None,
        max_size: Optional[str] = None,
        mtime_after: Optional[str] = None,
        mtime_before: Optional[str] = None,
        no_gitignore: bool = False,
        hidden: bool = False,
        case_sensitive: Optional[bool] = None,
        type: Optional[str] = None,
        extension: Optional[Union[str, List[str]]] = None,
        depth: Optional[int] = None,
    )):
        """Find files matching a glob pattern."""
    def search((
        self,
        pattern: str,
        content_pattern: str,
        root: str = ".",
        min_size: Optional[str] = None,
        max_size: Optional[str] = None,
        mtime_after: Optional[str] = None,
        mtime_before: Optional[str] = None,
        no_gitignore: bool = False,
        hidden: bool = False,
        case_sensitive: Optional[bool] = None,
        type: Optional[str] = None,
        extension: Optional[Union[str, List[str]]] = None,
        depth: Optional[int] = None,
        no_color: bool = False,
    )):
        """Search for content within files."""

def __init__((self)):

def _parse_size((self, size_str: str)) -> int:
    """Parse human-readable size strings like '10k', '1M', '500G'."""

def find((
        self,
        pattern: str = "*",
        root: str = ".",
        min_size: Optional[str] = None,
        max_size: Optional[str] = None,
        mtime_after: Optional[str] = None,
        mtime_before: Optional[str] = None,
        no_gitignore: bool = False,
        hidden: bool = False,
        case_sensitive: Optional[bool] = None,
        type: Optional[str] = None,
        extension: Optional[Union[str, List[str]]] = None,
        depth: Optional[int] = None,
    )):
    """Find files matching a glob pattern."""

def search((
        self,
        pattern: str,
        content_pattern: str,
        root: str = ".",
        min_size: Optional[str] = None,
        max_size: Optional[str] = None,
        mtime_after: Optional[str] = None,
        mtime_before: Optional[str] = None,
        no_gitignore: bool = False,
        hidden: bool = False,
        case_sensitive: Optional[bool] = None,
        type: Optional[str] = None,
        extension: Optional[Union[str, List[str]]] = None,
        depth: Optional[int] = None,
        no_color: bool = False,
    )):
    """Search for content within files."""

def main(()):
    """Main entry point for the CLI."""


</documents>